<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Pacman ‚Ä¢ Por Soamy Lanza</title>
  <style>
    :root{
      --bg:#0b0f14;
      --card:#121826;
      --line:#233049;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(900px 500px at 20% 10%, rgba(34,197,94,.14), transparent 55%),
                  radial-gradient(800px 500px at 80% 15%, rgba(245,158,11,.12), transparent 55%),
                  var(--bg);
      color: var(--text);
      overflow:hidden;
    }
    .app{
      height:100svh;
      max-width:1100px;
      margin:0 auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }
    header{
      background: rgba(18,24,38,.92);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:260px;
    }
    .title h1{
      margin:0;
      font-size:18px;
      display:flex;
      gap:8px;
      align-items:center;
      letter-spacing:.2px;
    }
    .title small{ color: var(--muted); }
    .byline{ color: var(--muted); font-size: 12px; margin-top:2px; }

    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .pill{
      border:1px solid var(--line);
      border-radius:999px;
      padding:6px 10px;
      background: rgba(11,15,20,.35);
      font-size:13px;
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill b{ font-variant-numeric: tabular-nums; }

    main{
      flex:1 1 auto;
      min-height:0;
      display:grid;
      grid-template-columns: 1fr;
    }
    .panel{
      background: rgba(18,24,38,.92);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      flex:0 0 auto;
    }
    .leftControls,.rightControls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }

    select,button{
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(11,15,20,.35);
      color: var(--text);
      padding:10px 12px;
      font-size:14px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button.primary{
      border-color: rgba(34,197,94,.45);
      background: rgba(34,197,94,.14);
    }
    button.warn{
      border-color: rgba(245,158,11,.45);
      background: rgba(245,158,11,.14);
    }

    .hint{
      color: var(--muted);
      font-size:13px;
      line-height:1.35;
      flex:0 0 auto;
    }

    .gameWrap{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
    }

    canvas{
      width: min(92vw, 560px);
      height: min(92vw, 560px);
      max-width: calc(100svh - 250px);
      max-height: calc(100svh - 250px);
      background: rgba(11,15,20,.35);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
      image-rendering: pixelated;
      touch-action: none;
    }

    .touchPad{
      display:none;
      gap:14px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 8px;
      flex:0 0 auto;
    }
    .touchPad button{
      width:78px; height:78px;
      padding:0;
      font-size:28px;
      border-radius:22px;
    }
    @media (max-width: 700px){
      .touchPad{ display:flex; }
    }

    .footer{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex:0 0 auto;
    }
    .status{
      color: var(--muted);
      font-size:13px;
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      border:1px solid var(--line);
      border-radius:999px;
      padding:5px 9px;
      font-size:12px;
      background: rgba(11,15,20,.35);
      color: var(--text);
    }
    .badge.ok{ border-color: rgba(34,197,94,.55); background: rgba(34,197,94,.10); }
    .badge.warn{ border-color: rgba(245,158,11,.55); background: rgba(245,158,11,.10); }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <div class="title">
        <h1>üëæ Mini Pacman</h1>
        <small>Come puntos ‚Ä¢ <b>los fantasmas te persiguen</b> ‚Ä¢ listo para GitHub Pages</small>
        <div class="byline">Por: <b>Soamy Lanza</b></div>
      </div>
      <div class="stats">
        <div class="pill">‚è±Ô∏è Tiempo: <b id="time">00:00.0</b></div>
        <div class="pill">‚≠ê Puntos: <b id="score">0</b></div>
        <div class="pill">‚ù§Ô∏è Vidas: <b id="lives">3</b></div>
        <div class="pill">üéöÔ∏è Dificultad: <b id="diffLabel">Medio</b></div>
      </div>
    </header>

    <main>
      <section class="panel" id="panel">
        <div class="controls">
          <div class="leftControls">
            <select id="difficulty" aria-label="Dificultad">
              <option value="easy">Bajo</option>
              <option value="medium" selected>Medio</option>
              <option value="hard">Alto</option>
            </select>
            <button class="primary" id="newBtn">Nuevo</button>
            <button class="warn" id="resetBtn">Reiniciar</button>
          </div>
          <div class="rightControls">
            <button id="shareBtn">Compartir</button>
          </div>
        </div>

        <div class="hint">
          PC: <b>WASD</b> o <b>flechas</b>. M√≥vil: usa los botones grandes abajo.
          Objetivo: comer todos los puntos sin que <b>los fantasmas te atrapen</b>.
        </div>

        <div class="gameWrap">
          <canvas id="game" width="640" height="640"></canvas>
        </div>

        <div class="touchPad" aria-label="Controles t√°ctiles">
          <button id="btnUp">‚¨ÜÔ∏è</button>
          <button id="btnLeft">‚¨ÖÔ∏è</button>
          <button id="btnDown">‚¨áÔ∏è</button>
          <button id="btnRight">‚û°Ô∏è</button>
        </div>

        <div class="footer">
          <div class="status" id="status">
            <span class="badge warn">En juego</span>
            <span>Come todos los puntos.</span>
          </div>
          <div class="hint">Una sola pantalla ‚Ä¢ comparte el link por WhatsApp/redes</div>
        </div>
      </section>
    </main>
  </div>

<script>
(() => {
  // DOM
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const timeEl  = document.getElementById("time");
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const diffEl  = document.getElementById("diffLabel");
  const statusEl= document.getElementById("status");

  const difficultySel = document.getElementById("difficulty");
  const newBtn = document.getElementById("newBtn");
  const resetBtn = document.getElementById("resetBtn");
  const shareBtn = document.getElementById("shareBtn");

  const btnUp = document.getElementById("btnUp");
  const btnDown = document.getElementById("btnDown");
  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");

  // Timer
  let timerId = null;
  let startTime = 0;
  let elapsedMs = 0;
  let runningTimer = false;

  const fmtTime = (ms) => {
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    const tenths  = Math.floor((ms % 1000) / 100);
    return `${String(minutes).padStart(2,"0")}:${String(seconds).padStart(2,"0")}.${tenths}`;
  };

  const startTimer = () => {
    if (runningTimer) return;
    runningTimer = true;
    startTime = performance.now() - elapsedMs;
    if (timerId) clearInterval(timerId);
    timerId = setInterval(() => {
      elapsedMs = performance.now() - startTime;
      timeEl.textContent = fmtTime(elapsedMs);
    }, 100);
  };
  const stopTimer = () => {
    runningTimer = false;
    if (timerId){ clearInterval(timerId); timerId = null; }
  };
  const resetTimer = () => {
    stopTimer();
    elapsedMs = 0;
    timeEl.textContent = fmtTime(0);
  };

  const setStatus = (type, text) => {
    const cls = type === "ok" ? "badge ok" : "badge warn";
    const label = type === "ok" ? "¬°Listo!" : "En juego";
    statusEl.innerHTML = `<span class="${cls}">${label}</span><span>${text}</span>`;
  };

  // Grid
  const TILE = 20;
  const GRID_W = 28;
  const GRID_H = 31;

  canvas.width  = GRID_W * TILE;
  canvas.height = GRID_H * TILE;

  const WALL = 1, DOT = 2, EMPTY = 0, POWER = 3;
  let map = [];
  let dotsLeft = 0;

  // Dificultad
  const DIFF = {
    easy:   { pacSpeed: 6.2, ghostSpeed: 4.2, ghostCount: 2, smartness: 0.20 },
    medium: { pacSpeed: 6.6, ghostSpeed: 5.2, ghostCount: 3, smartness: 0.45 },
    hard:   { pacSpeed: 7.0, ghostSpeed: 6.0, ghostCount: 4, smartness: 0.70 },
  };
  let diffKey = "medium";

  // Estado juego
  let score = 0;
  let lives = 3;
  let gameOver = false;
  let win = false;

  // Pacman
  const pac = {
    x: 1, y: 1,
    dirX: 0, dirY: 0,
    nextX: 1, nextY: 0,
    speed: 6.6,
    px: 0, py: 0,
    radius: TILE * 0.45,
    mouth: 0
  };

  // Fantasmas
  const ghosts = [];
  const GHOST_COLORS = ["#ff4d6d", "#4dd2ff", "#ffd166", "#b089ff"];
  let frightenedUntil = 0;

  let lastFrame = performance.now();

  const updateHUD = () => {
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    diffEl.textContent = diffKey === "easy" ? "Bajo" : diffKey === "hard" ? "Alto" : "Medio";
  };

  // Map generator
  const indexToRC = (i) => ({ r: Math.floor(i / GRID_W), c: i % GRID_W });
  const rcToIndex = (r,c) => r * GRID_W + c;

  const makeMap = () => {
    map = Array.from({length: GRID_H}, () => Array(GRID_W).fill(DOT));
    dotsLeft = 0;

    for (let x=0; x<GRID_W; x++){
      map[0][x] = WALL;
      map[GRID_H-1][x] = WALL;
    }
    for (let y=0; y<GRID_H; y++){
      map[y][0] = WALL;
      map[y][GRID_W-1] = WALL;
    }

    const wallRect = (x1,y1,x2,y2) => {
      for (let y=y1; y<=y2; y++){
        for (let x=x1; x<=x2; x++){
          map[y][x] = WALL;
        }
      }
    };

    wallRect(3, 3, 5, 8);
    wallRect(GRID_W-6, 3, GRID_W-4, 8);

    wallRect(10, 4, 17, 6);
    wallRect(10, GRID_H-7, 17, GRID_H-5);

    wallRect(7, 12, 9, 18);
    wallRect(GRID_W-10, 12, GRID_W-8, 18);

    wallRect(12, 10, 15, 12);
    wallRect(12, 18, 15, 20);

    wallRect(11, 13, 16, 17);
    map[13][13] = EMPTY; map[13][14] = EMPTY; map[13][15] = EMPTY;

    // t√∫neles
    map[15][0] = EMPTY;
    map[15][GRID_W-1] = EMPTY;

    // limpiar alrededor casa
    for (let y=12; y<=18; y++){
      for (let x=10; x<=17; x++){
        if (map[y][x] !== WALL) map[y][x] = EMPTY;
      }
    }

    // power
    const powers = [
      {x:2, y:2}, {x:GRID_W-3, y:2},
      {x:2, y:GRID_H-3}, {x:GRID_W-3, y:GRID_H-3},
    ];
    for (const p of powers){
      if (map[p.y][p.x] !== WALL) map[p.y][p.x] = POWER;
    }

    // convertir vac√≠os a dots (excepto casa)
    for (let y=1; y<GRID_H-1; y++){
      for (let x=1; x<GRID_W-1; x++){
        if (map[y][x] === WALL || map[y][x] === POWER) continue;
        const inHouse = (x>=11 && x<=16 && y>=13 && y<=17);
        map[y][x] = inHouse ? EMPTY : DOT;
      }
    }

    // zona inicio limpia
    for (let y=1; y<=3; y++){
      for (let x=1; x<=3; x++){
        if (map[y][x] !== WALL) map[y][x] = EMPTY;
      }
    }
    map[1][1] = EMPTY;

    // contar
    dotsLeft = 0;
    for (let y=0; y<GRID_H; y++){
      for (let x=0; x<GRID_W; x++){
        if (map[y][x] === DOT || map[y][x] === POWER) dotsLeft++;
      }
    }
  };

  const cell = (x,y) => {
    if (y === 15 && x < 0) return EMPTY;
    if (y === 15 && x >= GRID_W) return EMPTY;
    if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return WALL;
    return map[y][x];
  };
  const isWall = (x,y) => cell(x,y) === WALL;

  const wrapTunnel = (ent) => {
    if (Math.round(ent.y) === 15) {
      if (ent.x < 0) ent.x = GRID_W - 1;
      if (ent.x > GRID_W - 1) ent.x = 0;
      ent.px = ent.x * TILE + TILE/2;
    }
  };

  // Entities
  const resetEntities = () => {
    pac.x = 1; pac.y = 1;
    pac.dirX = 0; pac.dirY = 0;
    pac.nextX = 1; pac.nextY = 0;
    pac.px = pac.x*TILE + TILE/2;
    pac.py = pac.y*TILE + TILE/2;
    pac.mouth = 0;

    ghosts.length = 0;
    const gCount = DIFF[diffKey].ghostCount;
    const basePos = [
      {x:14, y:15},
      {x:13, y:15},
      {x:15, y:15},
      {x:14, y:14}
    ];
    for (let i=0; i<gCount; i++){
      const b = basePos[i] || basePos[0];
      ghosts.push({
        x: b.x, y: b.y,
        px: b.x*TILE + TILE/2,
        py: b.y*TILE + TILE/2,
        dirX: 0, dirY: -1,
        speed: DIFF[diffKey].ghostSpeed,
        color: GHOST_COLORS[i % GHOST_COLORS.length],
      });
    }
  };

  const applyDifficulty = () => {
    pac.speed = DIFF[diffKey].pacSpeed;
    for (const g of ghosts) g.speed = DIFF[diffKey].ghostSpeed;
    updateHUD();
  };

  // Input
  const setNextDir = (dx,dy) => {
    pac.nextX = dx; pac.nextY = dy;
    if (!gameOver && !win) startTimer();
  };

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    const handled = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"].includes(k);
    if (!handled) return;
    e.preventDefault();

    if (k === "arrowup" || k === "w") setNextDir(0,-1);
    if (k === "arrowdown" || k === "s") setNextDir(0, 1);
    if (k === "arrowleft" || k === "a") setNextDir(-1,0);
    if (k === "arrowright" || k === "d") setNextDir(1, 0);
  }, {passive:false});

  btnUp.addEventListener("click", () => setNextDir(0,-1));
  btnDown.addEventListener("click", () => setNextDir(0, 1));
  btnLeft.addEventListener("click", () => setNextDir(-1,0));
  btnRight.addEventListener("click", () => setNextDir(1, 0));

  // Movement (grid-snapped)
  const canMoveFrom = (x,y,dx,dy) => !isWall(x+dx, y+dy);

  const stepEntity = (ent, speedCps, dt) => {
    const step = speedCps * TILE * dt;

    // snap a centro si cerca
    const cx = ent.px / TILE;
    const cy = ent.py / TILE;
    const cellX = Math.round(cx - 0.5);
    const cellY = Math.round(cy - 0.5);
    const centerPx = cellX * TILE + TILE/2;
    const centerPy = cellY * TILE + TILE/2;
    const nearCenter = Math.abs(ent.px - centerPx) < 1.6 && Math.abs(ent.py - centerPy) < 1.6;

    if (nearCenter){
      ent.x = cellX; ent.y = cellY;
      ent.px = centerPx; ent.py = centerPy;
    }

    ent.px += ent.dirX * step;
    ent.py += ent.dirY * step;

    ent.x = Math.floor(ent.px / TILE);
    ent.y = Math.floor(ent.py / TILE);
  };

  const tryTurnPac = () => {
    const centerX = pac.x * TILE + TILE/2;
    const centerY = pac.y * TILE + TILE/2;
    const nearCenter = Math.abs(pac.px - centerX) < 2 && Math.abs(pac.py - centerY) < 2;
    if (!nearCenter) return;

    if (canMoveFrom(pac.x, pac.y, pac.nextX, pac.nextY)){
      pac.dirX = pac.nextX;
      pac.dirY = pac.nextY;
    }
    if (!canMoveFrom(pac.x, pac.y, pac.dirX, pac.dirY)){
      pac.dirX = 0; pac.dirY = 0;
    }
  };

  // Ghost AI
  const getNeighbors = (x,y) => {
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
    return dirs.filter(d => !isWall(x+d.dx, y+d.dy));
  };

  const pickGhostDir = (g) => {
    const centerX = g.x*TILE + TILE/2;
    const centerY = g.y*TILE + TILE/2;
    const nearCenter = Math.abs(g.px - centerX) < 2 && Math.abs(g.py - centerY) < 2;
    if (!nearCenter) return;

    g.px = centerX; g.py = centerY;

    const opts = getNeighbors(g.x, g.y);
    if (!opts.length) return;

    const rev = {dx:-g.dirX, dy:-g.dirY};
    let choices = opts;
    if (opts.length > 1){
      choices = opts.filter(o => !(o.dx === rev.dx && o.dy === rev.dy));
      if (!choices.length) choices = opts;
    }

    const now = performance.now();
    const frightened = now < frightenedUntil;
    const smartness = DIFF[diffKey].smartness;

    if (Math.random() < smartness){
      let best = choices[0];
      let bestScore = frightened ? -Infinity : Infinity;

      for (const c of choices){
        const nx = g.x + c.dx;
        const ny = g.y + c.dy;
        const dist = Math.abs(nx - pac.x) + Math.abs(ny - pac.y);
        if (!frightened){
          if (dist < bestScore){ bestScore = dist; best = c; }
        } else {
          if (dist > bestScore){ bestScore = dist; best = c; }
        }
      }
      g.dirX = best.dx; g.dirY = best.dy;
    } else {
      const pick = choices[Math.floor(Math.random()*choices.length)];
      g.dirX = pick.dx; g.dirY = pick.dy;
    }
  };

  // Eat + collisions
  const eat = () => {
    const centerX = pac.x*TILE + TILE/2;
    const centerY = pac.y*TILE + TILE/2;
    const nearCenter = Math.abs(pac.px - centerX) < 2 && Math.abs(pac.py - centerY) < 2;
    if (!nearCenter) return;

    const v = map[pac.y]?.[pac.x];
    if (v === DOT){
      map[pac.y][pac.x] = EMPTY;
      score += 10;
      dotsLeft--;
    } else if (v === POWER){
      map[pac.y][pac.x] = EMPTY;
      score += 50;
      dotsLeft--;
      frightenedUntil = performance.now() + 6500;
    }

    if (dotsLeft <= 0 && !win){
      win = true;
      stopTimer();
      setStatus("ok", `¬°Ganaste! Tiempo: ${fmtTime(elapsedMs)} ‚Ä¢ Puntos: ${score}`);
    }
    updateHUD();
  };

  const collide = (a,b,rad) => {
    const dx = a.px - b.px, dy = a.py - b.py;
    return (dx*dx + dy*dy) <= rad*rad;
  };

  const handleCollisions = () => {
    const now = performance.now();
    const frightened = now < frightenedUntil;

    for (const g of ghosts){
      if (collide(pac, g, TILE*0.55)){
        if (frightened){
          score += 200;
          g.x = 14; g.y = 15;
          g.px = g.x*TILE + TILE/2;
          g.py = g.y*TILE + TILE/2;
          g.dirX = 0; g.dirY = -1;
          setStatus("warn", "¬°Te comiste un fantasma! üòà‚û°Ô∏èüçΩÔ∏è");
          updateHUD();
        } else {
          lives--;
          updateHUD();
          if (lives <= 0){
            gameOver = true;
            stopTimer();
            setStatus("warn", `Game Over ‚Ä¢ Puntos: ${score} ‚Ä¢ Tiempo: ${fmtTime(elapsedMs)}`);
          } else {
            resetEntities();
            setStatus("warn", `¬°Te atraparon! Vidas restantes: ${lives}`);
          }
        }
        return;
      }
    }
  };

  // Loop
  const update = (dt) => {
    if (gameOver || win) return;

    tryTurnPac();
    stepEntity(pac, pac.speed, dt);

    // t√∫nel pac
    wrapTunnel(pac);

    // bloquear paredes
    if (isWall(pac.x, pac.y)){
      pac.px -= pac.dirX * pac.speed * TILE * dt;
      pac.py -= pac.dirY * pac.speed * TILE * dt;
      pac.dirX = 0; pac.dirY = 0;
    }

    eat();

    for (const g of ghosts){
      pickGhostDir(g);
      stepEntity(g, g.speed, dt);
      wrapTunnel(g);

      if (isWall(g.x, g.y)){
        g.px -= g.dirX * g.speed * TILE * dt;
        g.py -= g.dirY * g.speed * TILE * dt;
        const opts = getNeighbors(g.x, g.y);
        if (opts.length){
          const pick = opts[Math.floor(Math.random()*opts.length)];
          g.dirX = pick.dx; g.dirY = pick.dy;
        }
      }
    }

    handleCollisions();
    pac.mouth += dt * 10;
  };

  const draw = () => {
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // fondo
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(0,0,W,H);

    // mapa
    for (let y=0; y<GRID_H; y++){
      for (let x=0; x<GRID_W; x++){
        const v = map[y][x];
        const px = x*TILE, py = y*TILE;

        if (v === WALL){
          ctx.fillStyle = "rgba(77, 95, 138, .60)";
          ctx.fillRect(px, py, TILE, TILE);
          ctx.strokeStyle = "rgba(229,231,235,.10)";
          ctx.strokeRect(px+0.5, py+0.5, TILE-1, TILE-1);
        } else if (v === DOT){
          ctx.fillStyle = "rgba(229,231,235,.75)";
          ctx.beginPath();
          ctx.arc(px + TILE/2, py + TILE/2, 2.2, 0, Math.PI*2);
          ctx.fill();
        } else if (v === POWER){
          ctx.fillStyle = "rgba(245,158,11,.95)";
          ctx.beginPath();
          ctx.arc(px + TILE/2, py + TILE/2, 5.0, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // pacman
    const mouthOpen = (Math.sin(pac.mouth) + 1) / 2;
    const angle = Math.atan2(pac.dirY, pac.dirX) || 0;
    const mouth = 0.55 * mouthOpen;

    ctx.fillStyle = "#ffd166";
    ctx.beginPath();
    ctx.moveTo(pac.px, pac.py);
    ctx.arc(pac.px, pac.py, pac.radius, angle + mouth, angle + (Math.PI*2 - mouth), false);
    ctx.closePath();
    ctx.fill();

    // fantasmas
    const now = performance.now();
    const frightened = now < frightenedUntil;

    for (const g of ghosts){
      const gx = g.px, gy = g.py;
      const r = TILE*0.45;

      ctx.fillStyle = frightened ? "rgba(120, 200, 255, .95)" : g.color;
      ctx.beginPath();
      ctx.arc(gx, gy, r, Math.PI, 0);
      ctx.lineTo(gx + r, gy + r);
      ctx.lineTo(gx - r, gy + r);
      ctx.closePath();
      ctx.fill();

      // ojos
      ctx.fillStyle = "rgba(11,15,20,.95)";
      ctx.beginPath();
      ctx.arc(gx - r*0.35, gy - r*0.15, r*0.13, 0, Math.PI*2);
      ctx.arc(gx + r*0.35, gy - r*0.15, r*0.13, 0, Math.PI*2);
      ctx.fill();
    }

    if (gameOver || win){
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(229,231,235,.95)";
      ctx.font = "bold 26px system-ui";
      ctx.textAlign = "center";
      ctx.fillText(win ? "¬°GANASTE!" : "GAME OVER", W/2, H/2 - 12);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(229,231,235,.85)";
      ctx.fillText("Pulsa Nuevo o Reiniciar", W/2, H/2 + 18);
    }
  };

  const loop = (t) => {
    const dt = Math.min(0.035, (t - lastFrame) / 1000);
    lastFrame = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  };

  // Actions
  const newGame = () => {
    diffKey = difficultySel.value;
    score = 0;
    lives = 3;
    gameOver = false;
    win = false;
    frightenedUntil = 0;

    makeMap();
    resetEntities();
    applyDifficulty();
    resetTimer();
    setStatus("warn", "¬°Nuevo juego! Come todos los puntos.");
    updateHUD();
  };

  const restartGame = () => {
    score = 0;
    lives = 3;
    gameOver = false;
    win = false;
    frightenedUntil = 0;

    makeMap();
    resetEntities();
    applyDifficulty();
    resetTimer();
    setStatus("warn", "Reiniciado. ¬°A por esos puntos!");
    updateHUD();
  };

  const share = async () => {
    const url = location.href;
    const diffName = diffKey === "easy" ? "Bajo" : diffKey === "hard" ? "Alto" : "Medio";
    const text = `üëæ Mini Pacman (${diffName}) ‚Äî Por Soamy Lanza. Los fantasmas te persiguen üëª ¬øMe ganas?`;
    try{
      if (navigator.share){
        await navigator.share({ title: document.title, text, url });
      } else {
        await navigator.clipboard.writeText(url);
        alert("Link copiado ‚úÖ\nP√©galo en WhatsApp o redes.");
      }
    } catch {
      try{
        await navigator.clipboard.writeText(url);
        alert("Link copiado ‚úÖ");
      } catch {
        prompt("Copia este link:", url);
      }
    }
  };

  // Events
  newBtn.addEventListener("click", newGame);
  resetBtn.addEventListener("click", restartGame);
  difficultySel.addEventListener("change", newGame);
  shareBtn.addEventListener("click", share);

  // Init
  newGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
