from dataclasses import dataclass, field
from typing import List, Dict
import textwrap

@dataclass
class DiagnosticoEstrategicoOrganizacional:
    fortalezas: List[str] = field(default_factory=list)
    oportunidades: List[str] = field(default_factory=list)
    debilidades: List[str] = field(default_factory=list)
    amenazas: List[str] = field(default_factory=list)

def pedir_lista(titulo: str) -> List[str]:
    print(f"\n=== {titulo} ===")
    print("Escribe un ítem por línea. Deja vacío y presiona Enter para terminar.\n")
    items: List[str] = []
    while True:
        x = input("- ").strip()
        if x == "":
            break
        items.append(x)
    return items

def acciones_por_regla(items: List[str], regla: str) -> List[str]:
    """
    Genera acciones directas según la regla metodológica.
    """
    verbos = {
        "capitalizan": "Capitalizar",
        "corrigen": "Corregir",
        "gestionan": "Gestionar",
        "explotan": "Explotar",
        "mitigan": "Mitigar",
    }
    verbo = verbos.get(regla, "Gestionar")
    return [f"Acción: {verbo} {it}." for it in items]

def generar_estrategias_cruzadas(de: DiagnosticoEstrategicoOrganizacional, limite: int = 30) -> List[str]:
    """
    Estrategias tipo FO/DO/FA/DA (reglas simples, sin IA).
    Se limita la cantidad para evitar listas enormes.
    """
    cruces: List[str] = []

    # Tomamos hasta 5 por categoría para no explotar (jeje) la consola
    F = de.fortalezas[:5]
    O = de.oportunidades[:5]
    D = de.debilidades[:5]
    A = de.amenazas[:5]

    for f in F:
        for o in O:
            cruces.append(f"Estrategia FO: Capitalizar '{f}' para explotar '{o}'.")

    for d in D:
        for o in O:
            cruces.append(f"Estrategia DO: Corregir/gestionar '{d}' aprovechando '{o}'.")

    for f in F:
        for a in A:
            cruces.append(f"Estrategia FA: Capitalizar '{f}' para mitigar '{a}'.")

    for d in D:
        for a in A:
            cruces.append(f"Estrategia DA: Reducir '{d}' para disminuir el riesgo de '{a}'.")

    return cruces[:limite]

def generar_plan(de: DiagnosticoEstrategicoOrganizacional) -> Dict[str, List[str]]:
    """
    Plan estratégico basado en:
    - Fortalezas → se capitalizan
    - Debilidades → se corrigen / gestionan
    - Oportunidades → se explotan
    - Amenazas → se mitigan
    """
    plan: Dict[str, List[str]] = {
        "Fortalezas → se capitalizan": acciones_por_regla(de.fortalezas, "capitalizan"),
        "Debilidades → se corrigen": acciones_por_regla(de.debilidades, "corrigen"),
        "Debilidades → se gestionan": acciones_por_regla(de.debilidades, "gestionan"),
        "Oportunidades → se explotan": acciones_por_regla(de.oportunidades, "explotan"),
        "Amenazas → se mitigan": acciones_por_regla(de.amenazas, "mitigan"),
        "Estrategias cruzadas (FO/DO/FA/DA)": generar_estrategias_cruzadas(de),
    }
    return plan

def imprimir_plan(plan: Dict[str, List[str]]) -> None:
    print("\n" + "=" * 76)
    print("DIAGNÓSTICO ESTRATÉGICO ORGANIZACIONAL — PLAN ESTRATÉGICO")
    print("=" * 76)

    for seccion, acciones in plan.items():
        print(f"\n## {seccion}")
        if not acciones:
            print("  (Sin elementos ingresados)")
            continue
        for i, a in enumerate(acciones, 1):
            wrapped = textwrap.fill(a, width=76, subsequent_indent=" " * 6)
            print(f"  {i}. {wrapped}")

def main():
    print("Diagnóstico estratégico organizacional (Script único)\n")
    print("Vas a ingresar Fortalezas, Oportunidades, Debilidades y Amenazas.")
    print("Luego se genera un plan según las reglas metodológicas.\n")

    de = DiagnosticoEstrategicoOrganizacional(
        fortalezas=pedir_lista("Fortalezas"),
        oportunidades=pedir_lista("Oportunidades"),
        debilidades=pedir_lista("Debilidades"),
        amenazas=pedir_lista("Amenazas"),
    )

    plan = generar_plan(de)
    imprimir_plan(plan)

if __name__ == "__main__":
    main()
