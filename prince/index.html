<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Platformer Cinem√°tico ‚Äî Guardia & Combate</title>
  <style>
    :root{
      --bg:#0b1220; --card:rgba(255,255,255,.06); --border:rgba(255,255,255,.10);
      --text:#e9eefc; --muted:#a9b4d0; --accent:#6ee7ff; --bad:#ff5c7a; --good:#39d98a; --warn:#ffd166;
      --shadow:0 18px 40px rgba(0,0,0,.35); --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
      background:
        radial-gradient(900px 500px at 20% 10%, #18305c 0%, transparent 60%),
        radial-gradient(900px 600px at 90% 30%, #0d3b4a 0%, transparent 55%),
        var(--bg);
      min-height:100svh; display:flex; justify-content:center; padding:16px;
    }
    .wrap{width:min(1100px,100%); display:flex; flex-direction:column; gap:12px}
    header{
      display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:space-between;
      background:var(--card); border:1px solid var(--border); border-radius:var(--r);
      padding:14px; box-shadow:var(--shadow); backdrop-filter: blur(8px);
    }
    .title{min-width:260px}
    .title h1{margin:0; font-size:18px}
    .title p{margin:4px 0 0; color:var(--muted); font-size:13px; line-height:1.35}
    .panel{display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end}
    .chip{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      display:flex; gap:10px; align-items:center;
      font-size: 13px; color: var(--muted);
      white-space: nowrap;
    }
    .chip b{color:var(--text); font-weight:800}
    button{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none; -webkit-tap-highlight-color: transparent;
    }
    button:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18); }
    button:active{ transform: scale(.98); }

    .main{
      display:grid; grid-template-columns: 1fr 340px; gap:12px; align-items:start;
    }
    .card{
      background:var(--card); border:1px solid var(--border); border-radius:var(--r);
      padding:14px; box-shadow:var(--shadow); backdrop-filter: blur(8px);
    }
    canvas{
      width:100%; height:auto; aspect-ratio: 16/9;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.08));
      display:block;
    }
    .hint{color:var(--muted); font-size:13px; line-height:1.35; margin-top:10px}
    .log{
      margin-top:10px; padding:10px; border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.15);
      color: var(--muted); font-size: 13px; white-space: pre-line; min-height: 110px;
    }

    /* Mobile controls */
    .touch{
      display:none;
      margin-top:12px;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
    }
    .pad{display:flex; gap:10px; align-items:center;}
    .btnTouch{
      width:56px; height:56px; border-radius:16px;
      display:flex; align-items:center; justify-content:center;
      font-size:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
    }
    @media (max-width: 900px){
      .main{ grid-template-columns: 1fr; }
      .touch{ display:flex; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <h1>Platformer cinem√°tico ‚Äî Guardia & Combate</h1>
      <p>
        PC: ‚Üê‚Üí / A D moverse ¬∑ Espacio saltar ¬∑ <b>J atacar</b> ¬∑ <b>K bloquear</b><br>
        M√≥vil: usa botones. Objetivo: vence al guardia y llega a la puerta.
      </p>
    </div>
    <div class="panel">
      <div class="chip">‚è±Ô∏è Tiempo: <b id="time">00:00</b></div>
      <div class="chip">‚≠ê Puntaje: <b id="score">0</b></div>
      <button id="btnRestart">Reiniciar</button>
    </div>
  </header>

  <section class="main">
    <div class="card">
      <canvas id="c" width="960" height="540"></canvas>

      <div class="touch" aria-label="Controles t√°ctiles">
        <div class="pad">
          <div class="btnTouch" id="left">‚¨ÖÔ∏è</div>
          <div class="btnTouch" id="right">‚û°Ô∏è</div>
          <div class="btnTouch" id="jump">‚§¥Ô∏è</div>
        </div>
        <div class="pad">
          <div class="btnTouch" id="atk">‚öîÔ∏è</div>
          <div class="btnTouch" id="blk">üõ°Ô∏è</div>
        </div>
      </div>
    </div>

    <aside class="card">
      <div class="hint">
        <b>Combate b√°sico:</b><br>
        ‚Ä¢ Ataque ‚öîÔ∏è: pega si est√°s cerca y mirando al guardia.<br>
        ‚Ä¢ Bloqueo üõ°Ô∏è: reduce da√±o y evita retroceso si lo haces a tiempo.<br><br>
        <b>Tip:</b> atacar ‚Äúen spam‚Äù = te castigan. Bloquea y contraataca.
      </div>
      <div class="log" id="log">Listo. Tip: ac√©rcate, bloquea el primer golpe y responde.</div>
    </aside>
  </section>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const timeEl = document.getElementById('time');
  const scoreEl = document.getElementById('score');
  const logEl = document.getElementById('log');
  const btnRestart = document.getElementById('btnRestart');

  // Touch buttons
  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');
  const jumpBtn = document.getElementById('jump');
  const atkBtn = document.getElementById('atk');
  const blkBtn = document.getElementById('blk');

  // World constants
  const GRAV = 2200;
  const MOVE = 520;
  const JUMP = 820;
  const FRICTION = 0.84;
  const AIR = 0.94;

  // Combat constants
  const HIT_RANGE = 54;       // distance between centers
  const HIT_COOLDOWN = 0.42;  // seconds between attacks
  const HIT_STUN = 0.22;      // seconds of stun when hit
  const BLOCK_WINDOW = 0.12;  // seconds: perfect block timing bonus
  const KNOCK = 280;          // knockback velocity
  const DMG = 16;             // base damage per hit
  const DMG_BLOCK = 5;        // damage if blocked
  const MAX_HP = 100;

  // Level layout
  const level = {
    start: {x: 90, y: 380},
    door:  {x: 880, y: 310, w: 44, h: 86},
    platforms: [
      rect(0, 470, 960, 70),
      rect(120, 380, 180, 20),
      rect(350, 320, 170, 20),
      rect(560, 260, 140, 20),
      rect(720, 360, 180, 20),
      rect(760, 180, 140, 20),
      rect(420, 200, 160, 20),
    ],
    walls: [
      rect(0, 0, 20, 540),
      rect(940, 0, 20, 540),
    ],
    spikes: [
      rect(300, 450, 60, 20),
      rect(520, 450, 60, 20),
      rect(660, 450, 60, 20),
      rect(720, 340, 60, 20),
    ]
  };

  function rect(x,y,w,h){ return {x,y,w,h}; }

  function aabb(a,b){
    return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function formatTime(s){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  // Entities
  const player = makeFighter(level.start.x, level.start.y, "player");
  const guard  = makeFighter(650, 380, "guard");

  function makeFighter(x,y,type){
    return {
      type,
      x,y,w:34,h:58,
      vx:0, vy:0,
      onGround:false,
      facing: type==="player" ? 1 : -1,
      hp: MAX_HP,
      alive:true,
      attacking:false,
      attackT:0,
      atkCd:0,
      blocking:false,
      blockT:0,
      stunned:0,
      hitFlash:0,
    };
  }

  // Game state
  let keys = new Set();
  let score = 0;
  let running = true;

  // Timer
  let started = false;
  let seconds = 0;
  let timerId = null;

  function log(msg){ logEl.textContent = msg; }

  function startTimer(){
    if(started) return;
    started = true;
    timerId = setInterval(() => {
      seconds++;
      timeEl.textContent = formatTime(seconds);
      updateScore();
    }, 1000);
  }
  function stopTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null; started = false;
  }
  function resetTimer(){
    stopTimer();
    seconds = 0;
    timeEl.textContent = "00:00";
  }

  function resetGame(){
    Object.assign(player, makeFighter(level.start.x, level.start.y, "player"));
    Object.assign(guard, makeFighter(650, 380, "guard"));
    score = 0;
    scoreEl.textContent = score;
    resetTimer();
    keys.clear();
    running = true;
    log("Reiniciado. Bloquea (K/üõ°Ô∏è) y contraataca (J/‚öîÔ∏è).");
  }
  btnRestart.addEventListener('click', resetGame);

  // Input (keyboard)
  addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    const blockKeys = ["arrowleft","arrowright","a","d"," ","w","arrowup","j","k"];
    if(blockKeys.includes(k) || e.key === " "){ e.preventDefault(); }
    keys.add(e.key === " " ? "space" : k);
  }, {passive:false});

  addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    keys.delete(e.key === " " ? "space" : k);
  });

  // Touch hold helpers
  function bindHold(el, downKey){
    const down = (ev)=>{ ev.preventDefault(); keys.add(downKey); };
    const up   = (ev)=>{ ev.preventDefault(); keys.delete(downKey); };
    el.addEventListener('pointerdown', down);
    el.addEventListener('pointerup', up);
    el.addEventListener('pointercancel', up);
    el.addEventListener('pointerleave', up);
  }
  bindHold(leftBtn, "arrowleft");
  bindHold(rightBtn,"arrowright");
  bindHold(jumpBtn, "space");
  bindHold(atkBtn,  "j");
  bindHold(blkBtn,  "k");

  function solids(){ return level.platforms.concat(level.walls); }

  function moveAndCollide(entity, dt){
    // Reduce timers
    entity.atkCd = Math.max(0, entity.atkCd - dt);
    entity.stunned = Math.max(0, entity.stunned - dt);
    entity.hitFlash = Math.max(0, entity.hitFlash - dt);

    // Blocking timer
    if(entity.blocking) entity.blockT += dt; else entity.blockT = 0;

    // Attack timer
    if(entity.attacking){
      entity.attackT += dt;
      if(entity.attackT > 0.18){
        entity.attacking = false;
        entity.attackT = 0;
      }
    }

    // If stunned: limited control
    const canControl = entity.stunned <= 0;

    // Player control
    if(entity.type === "player" && canControl){
      const left = keys.has("arrowleft") || keys.has("a");
      const right = keys.has("arrowright") || keys.has("d");
      const jump = keys.has("space") || keys.has("w") || keys.has("arrowup");
      const atk = keys.has("j");
      const blk = keys.has("k");

      entity.blocking = !!blk;

      if(left && !right){ entity.vx -= MOVE * dt; entity.facing = -1; }
      if(right && !left){ entity.vx += MOVE * dt; entity.facing = 1; }

      if(jump && entity.onGround){
        entity.vy = -JUMP;
        entity.onGround = false;
        startTimer();
      }

      if(atk) tryAttack(entity, guard);

      if((left || right || atk || blk) && !started) startTimer();
    }

    // Gravity
    entity.vy += GRAV * dt;

    // Friction / air
    entity.vx *= entity.onGround ? (entity.blocking ? 0.72 : FRICTION) : AIR;

    // Clamp speeds
    entity.vx = clamp(entity.vx, -520, 520);

    // Move X
    entity.x += entity.vx * dt;
    for(const s of solids()){
      if(aabb(entity, s)){
        if(entity.vx > 0) entity.x = s.x - entity.w;
        else if(entity.vx < 0) entity.x = s.x + s.w;
        entity.vx = 0;
      }
    }

    // Move Y
    entity.y += entity.vy * dt;
    entity.onGround = false;
    for(const s of solids()){
      if(aabb(entity, s)){
        if(entity.vy > 0){
          entity.y = s.y - entity.h;
          entity.vy = 0;
          entity.onGround = true;
        } else if(entity.vy < 0){
          entity.y = s.y + s.h;
          entity.vy = 0;
        }
      }
    }
  }

  function centerX(e){ return e.x + e.w/2; }
  function centerY(e){ return e.y + e.h/2; }

  function facingTarget(attacker, target){
    const dx = centerX(target) - centerX(attacker);
    return (dx === 0) || (dx > 0 && attacker.facing > 0) || (dx < 0 && attacker.facing < 0);
  }

  function dist(a,b){
    const dx = centerX(a)-centerX(b);
    const dy = centerY(a)-centerY(b);
    return Math.hypot(dx,dy);
  }

  function tryAttack(attacker, target){
    if(!attacker.alive || !target.alive) return;
    if(attacker.atkCd > 0) return;
    if(attacker.blocking) return; // can't attack while blocking (basic)
    attacker.attacking = true;
    attacker.attackT = 0;
    attacker.atkCd = HIT_COOLDOWN;

    // Hit check (instant)
    if(dist(attacker, target) <= HIT_RANGE && facingTarget(attacker, target)){
      applyHit(attacker, target);
    }
  }

  function applyHit(attacker, target){
    // Determine if target blocks
    const isBlocking = target.blocking && facingTarget(target, attacker);
    const perfect = isBlocking && target.blockT <= BLOCK_WINDOW;

    const dmg = isBlocking ? (perfect ? 0 : DMG_BLOCK) : DMG;
    if(dmg > 0){
      target.hp = Math.max(0, target.hp - dmg);
      target.hitFlash = 0.18;
    }

    // Knockback unless perfect block
    if(!perfect){
      const dir = Math.sign(centerX(target) - centerX(attacker)) || (attacker.facing);
      target.vx = dir * KNOCK;
      target.vy = -260;
      target.onGround = false;
      target.stunned = HIT_STUN;
    }

    // Feedback/log
    if(target.type === "player"){
      if(perfect) log("üõ°Ô∏è ¬°Bloqueo perfecto! (0 da√±o)");
      else if(isBlocking) log(`üõ°Ô∏è Bloqueaste. Da√±o reducido (-${DMG_BLOCK}).`);
      else log(`üí• Te pegaron (-${DMG}).`);
    } else {
      if(perfect) log("El guardia hizo bloqueo perfecto. Qu√© atrevido.");
      else if(isBlocking) log("El guardia bloque√≥ parte del da√±o.");
      else log("Golpe conectado. Sigue presionando (pero con cabeza).");
    }

    // Kill check
    if(target.hp <= 0){
      target.alive = false;
      target.vx = 0;
      target.vy = 0;
      if(target.type === "guard"){
        log("‚úÖ Guardia derrotado. Ahora corre a la puerta üü®.");
      } else {
        log("üíÄ Ca√≠ste en combate. Reinicia para intentarlo de nuevo.");
      }
    }
  }

  // Guard AI
  let aiThink = 0;

  function guardAI(dt){
    if(!guard.alive || !player.alive) return;

    // Face player
    const dx = centerX(player) - centerX(guard);
    guard.facing = dx >= 0 ? 1 : -1;

    // Timers
    aiThink -= dt;

    // Simple decision cadence
    if(aiThink <= 0 && guard.stunned <= 0){
      aiThink = 0.10 + Math.random()*0.10;

      const d = Math.abs(dx);
      const inRange = d <= HIT_RANGE;
      const wantsClose = d > 120;

      // Occasionally block if player is attacking and close-ish
      const playerThreat = player.attacking && d < 90;

      if(playerThreat && Math.random() < 0.65){
        guard.blocking = true;
      } else {
        // Sometimes stop blocking to attack/move
        guard.blocking = false;

        // Attack if in range
        if(inRange && guard.atkCd <= 0 && Math.random() < 0.75){
          tryAttack(guard, player);
        }
      }

      // Movement intention
      if(guard.stunned <= 0){
        if(wantsClose){
          // approach but don't walk into spikes too much
          guard.vx += Math.sign(dx) * (MOVE*0.55) * dt;
        } else if(d < 70 && Math.random() < 0.35){
          // small retreat to bait
          guard.vx += -Math.sign(dx) * (MOVE*0.35) * dt;
        }
      }
    }

    // If blocking, reduce movement
    if(guard.blocking) guard.vx *= 0.85;
  }

  // Hazards and win
  function checkSpikes(entity){
    for(const s of level.spikes){
      if(aabb(entity, s)){
        // No gore: just reset position and damage
        entity.hp = Math.max(0, entity.hp - 18);
        entity.hitFlash = 0.18;
        entity.x = (entity.type==="player") ? level.start.x : 650;
        entity.y = (entity.type==="player") ? level.start.y : 380;
        entity.vx = 0; entity.vy = 0; entity.onGround=false;
        entity.stunned = 0.18;
        if(entity.hp <= 0){
          entity.alive = false;
          log(entity.type==="player" ? "üíÄ Pinchos te dejaron fuera de juego." : "El guardia cay√≥ por pinchos. Muy‚Ä¶ competente.");
        } else {
          if(entity.type==="player") log("üü• Pinchos. Penalizaci√≥n de vida. (S√≠, duelen‚Ä¶ metaf√≥ricamente).");
        }
      }
    }
  }

  function checkWin(){
    // Must defeat guard, then reach door
    if(player.alive && !guard.alive && aabb(player, level.door)){
      stopTimer();
      running = false;
      const bonus = Math.max(0, 1000 - seconds * 12);
      score += bonus;
      scoreEl.textContent = score;
      log(`üèÅ ¬°Nivel completado! Bonus tiempo: +${bonus}. Puntaje final: ${score}.`);
    }
  }

  function updateScore(){
    // Score = progress + guard damage bonus - time penalty
    const progress = Math.round((player.x / 960) * 500);
    const dmgDone = (MAX_HP - guard.hp) * 6;
    const dmgTaken = (MAX_HP - player.hp) * 4;
    const timePenalty = Math.floor(seconds * 2);
    score = Math.max(0, 200 + progress + dmgDone - dmgTaken - timePenalty);
    scoreEl.textContent = score;
  }

  // Drawing helpers
  function roundedRect(x,y,w,h,r, fill, stroke){
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = stroke; ctx.lineWidth = 1; ctx.stroke();
    ctx.restore();
  }

  function drawSpikes(s){
    ctx.save();
    roundedRect(s.x, s.y, s.w, s.h, 10, "rgba(255,92,122,.12)", "rgba(255,92,122,.30)");
    ctx.fillStyle = "rgba(255,92,122,.22)";
    ctx.strokeStyle = "rgba(255,92,122,.55)";
    const n = Math.max(3, Math.floor(s.w/12));
    const step = s.w / n;
    for(let i=0;i<n;i++){
      const x = s.x + i*step;
      ctx.beginPath();
      ctx.moveTo(x, s.y+s.h);
      ctx.lineTo(x+step/2, s.y+4);
      ctx.lineTo(x+step, s.y+s.h);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawDoor(d){
    ctx.save();
    roundedRect(d.x, d.y, d.w, d.h, 14, "rgba(255,209,102,.20)", "rgba(255,209,102,.65)");
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,209,102,.85)";
    ctx.fillRect(d.x + 10, d.y + 14, d.w - 20, 10);
    ctx.fillRect(d.x + 10, d.y + 32, d.w - 20, 10);
    ctx.fillRect(d.x + 10, d.y + 50, d.w - 20, 10);
    ctx.restore();
  }

  function drawFighter(e){
    ctx.save();
    const flash = e.hitFlash > 0;
    const outline = e.type==="player" ? "rgba(110,231,255,.30)" : "rgba(255,209,102,.30)";
    const fill = e.type==="player" ? "rgba(110,231,255,.12)" : "rgba(255,209,102,.12)";

    roundedRect(e.x, e.y, e.w, e.h, 14,
      flash ? "rgba(255,255,255,.20)" : fill,
      flash ? "rgba(255,255,255,.55)" : outline
    );

    // head
    ctx.beginPath();
    ctx.arc(e.x + e.w/2, e.y + 14, 10, 0, Math.PI*2);
    ctx.fillStyle = flash ? "rgba(255,255,255,.35)" : "rgba(233,238,252,.22)";
    ctx.fill();
    ctx.strokeStyle = "rgba(233,238,252,.22)";
    ctx.stroke();

    // eye (direction)
    ctx.beginPath();
    ctx.arc(e.x + e.w/2 + (e.facing*4), e.y + 14, 2.4, 0, Math.PI*2);
    ctx.fillStyle = "rgba(233,238,252,.70)";
    ctx.fill();

    // sword/shield simple icons
    if(e.attacking){
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 3;
      const sx = e.x + e.w/2 + e.facing*18;
      const sy = e.y + 30;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + e.facing*18, sy + 10);
      ctx.stroke();
    }
    if(e.blocking){
      ctx.globalAlpha = 0.9;
      roundedRect(e.x + (e.facing>0 ? e.w-10 : -2), e.y + 26, 12, 22, 8,
        "rgba(57,217,138,.12)", "rgba(57,217,138,.35)"
      );
    }

    ctx.restore();
  }

  function drawHPBars(){
    // top overlay bars
    const pad = 16;
    const barW = 260, barH = 12;

    // Player bar (left)
    drawBar(pad, pad+44, barW, barH, player.hp/MAX_HP, "Jugador (Negro/azul)");
    // Guard bar (right)
    drawBar(960 - pad - barW, pad+44, barW, barH, guard.hp/MAX_HP, "Guardia (Dorado)");
  }

  function drawBar(x,y,w,h,p,label){
    ctx.save();
    ctx.globalAlpha = 0.9;
    roundedRect(x,y,w,h, 8, "rgba(255,255,255,.08)", "rgba(255,255,255,.14)");
    // fill (no fixed colors rule here; but this is not matplotlib‚Äîfine to set)
    ctx.fillStyle = "rgba(110,231,255,.30)";
    ctx.fillRect(x+2, y+2, Math.max(0,(w-4)*p), h-4);
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(233,238,252,.82)";
    ctx.font = "12px system-ui,Segoe UI,Arial";
    ctx.fillText(label, x, y-6);
    ctx.restore();
  }

  function drawCredit(){
    const txt = "Por: Soamy ‚Äî Lanza 2025.1";
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(960-270, 12, 258, 26);
    ctx.fillStyle = "rgba(233,238,252,.88)";
    ctx.font = "13px system-ui,Segoe UI,Arial";
    ctx.fillText(txt, 960-262, 30);
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,960,540);

    // background
    ctx.save();
    ctx.globalAlpha = 0.65;
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(0,0,960,540);
    ctx.restore();

    // columns ambience
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#e9eefc";
    for(let x=60;x<960;x+=120) ctx.fillRect(x, 60, 18, 420);
    ctx.restore();

    // platforms/walls
    for(const p of level.platforms){
      roundedRect(p.x,p.y,p.w,p.h, 12, "rgba(233,238,252,.10)", "rgba(233,238,252,.16)");
    }
    for(const w of level.walls){
      roundedRect(w.x,w.y,w.w,w.h, 12, "rgba(110,231,255,.07)", "rgba(110,231,255,.14)");
    }
    for(const s of level.spikes) drawSpikes(s);
    drawDoor(level.door);

    // fighters
    if(player.alive) drawFighter(player);
    if(guard.alive) drawFighter(guard);

    drawHPBars();
    drawCredit();

    // objective label
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fillRect(14, 14, 310, 34);
    ctx.fillStyle = "rgba(233,238,252,.92)";
    ctx.font = "14px system-ui,Segoe UI,Arial";
    const obj = guard.alive ? "Objetivo: vence al guardia ‚öîÔ∏è" : "Objetivo: llega a la puerta üü®";
    ctx.fillText(obj, 24, 36);
    ctx.restore();
  }

  // Combat + AI update
  function update(dt){
    if(!running) return;

    // Guard AI decisions
    guardAI(dt);

    // Guard blocking toggled can persist; but if stunned, drop block
    if(guard.stunned > 0) guard.blocking = false;

    // Move/collide entities
    moveAndCollide(player, dt);
    moveAndCollide(guard, dt);

    // Start timer on first interaction
    if(!started && (keys.has("arrowleft")||keys.has("arrowright")||keys.has("a")||keys.has("d")||keys.has("j")||keys.has("k"))){
      startTimer();
    }

    // Spikes (no gore)
    if(player.alive) checkSpikes(player);
    if(guard.alive) checkSpikes(guard);

    // Auto-pass guard if falls off? (prevent stuck)
    if(guard.y > 520){ guard.hp = 0; guard.alive = false; log("El guardia desapareci√≥ del mapa. Lo tomamos como victoria üòÖ"); }

    // Win condition
    checkWin();

    // Score update (continuous)
    updateScore();
  }

  // Loop
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  }

  // Helpers
  // (Prevent player walking through guard too much: simple separation)
  function separate(){
    if(!player.alive || !guard.alive) return;
    const overlapX = Math.min(player.x+player.w, guard.x+guard.w) - Math.max(player.x, guard.x);
    const overlapY = Math.min(player.y+player.h, guard.y+guard.h) - Math.max(player.y, guard.y);
    if(overlapX > 0 && overlapY > 0){
      const push = overlapX/2 + 0.5;
      if(centerX(player) < centerX(guard)){
        player.x -= push; guard.x += push;
      }else{
        player.x += push; guard.x -= push;
      }
      player.vx *= 0.8; guard.vx *= 0.8;
    }
  }
  // call separation each frame by monkey patching update
  const _update = update;
  update = function(dt){
    _update(dt);
    separate();
  };

  // Boot
  resetGame();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
