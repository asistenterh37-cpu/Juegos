<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Damero ‚Äî Estrategia</title>
  <style>
    :root{
      --bg:#0b1220;
      --card: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.10);
      --text:#e9eefc;
      --muted:#a9b4d0;
      --accent:#6ee7ff;
      --good:#39d98a;
      --warn:#ffd166;
      --bad:#ff5c7a;
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --r: 18px;
      --cell: min(10.8vw, 64px);
      --gap: 6px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 20% 10%, #18305c 0%, transparent 60%),
        radial-gradient(900px 600px at 90% 30%, #0d3b4a 0%, transparent 55%),
        var(--bg);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 18px;
    }
    .wrap{ width:min(1100px, 100%); display:flex; flex-direction:column; gap:14px; }

    header{
      display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:space-between;
      background: var(--card);
      border:1px solid var(--border);
      border-radius: var(--r);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title{ display:flex; flex-direction:column; gap:2px; min-width:280px; }
    .title h1{ margin:0; font-size: 18px; letter-spacing:.2px; }
    .title p{ margin:0; font-size: 13px; color:var(--muted); }
    .credit{
      margin-top:6px;
      display:inline-flex;
      width: fit-content;
      gap:8px;
      align-items:center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 12.5px;
      letter-spacing:.2px;
    }
    .credit b{ color: var(--text); }

    .panel{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end; }

    .chip{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }
    .chip b{ color:var(--text); font-weight: 800; }

    select, button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    select{
      padding-right: 34px;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(233,238,252,.9) 50%),
        linear-gradient(135deg, rgba(233,238,252,.9) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) 55%,
        calc(100% - 12px) 55%;
      background-size: 6px 6px, 6px 6px;
      background-repeat:no-repeat;
    }
    button:hover, select:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18); }
    button:active, select:active{ transform: scale(.98); }
    button.primary{ border-color: rgba(110,231,255,.35); }
    button.danger{ border-color: rgba(255,92,122,.35); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .main{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 14px;
      align-items:start;
    }
    .card{
      background: var(--card);
      border:1px solid var(--border);
      border-radius: var(--r);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .boardWrap{ display:flex; justify-content:center; }
    .board{
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--gap);
      padding: 12px;
      background: rgba(16,26,47,.55);
      border:1px solid rgba(255,255,255,.09);
      border-radius: 18px;
      width: fit-content;
      max-width: 100%;
      overflow:auto;
    }
    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      cursor:pointer;
      touch-action: manipulation;
      overflow:hidden;
    }
    .cell.light{ background: rgba(233,238,252,.07); }
    .cell.dark{
      background:
        radial-gradient(120px 80px at 40% 20%, rgba(110,231,255,.10), transparent 55%),
        rgba(18, 95, 65, .45);
    }

    .cell.sel{
      outline: 3px solid rgba(110,231,255,.65);
      box-shadow: 0 0 0 6px rgba(110,231,255,.14);
    }
    .cell.move::after{
      content:"";
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: rgba(110,231,255,.85);
      box-shadow: 0 0 0 7px rgba(110,231,255,.12);
      position:absolute;
      opacity:.95;
    }
    .cell.capture::after{
      background: rgba(255,209,102,.92);
      box-shadow: 0 0 0 7px rgba(255,209,102,.15);
    }

    .piece{
      width: 78%;
      height: 78%;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 20px rgba(0,0,0,.32);
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .p1{
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.18), transparent 45%),
                  linear-gradient(180deg, rgba(80,92,120,.35), rgba(0,0,0,.55));
    }
    .p2{
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.85), rgba(255,255,255,.25) 55%, rgba(255,255,255,.08));
      border-color: rgba(255,255,255,.35);
    }
    .kingMark{
      width: 64%;
      height: 64%;
      border-radius: 999px;
      border: 2px solid rgba(255,209,102,.75);
      background: rgba(255,209,102,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      color: rgba(255,209,102,.92);
      font-size: 16px;
      letter-spacing:.5px;
    }

    .side h2{ margin:0 0 8px 0; font-size: 16px; }
    .side p{ margin:0 0 10px 0; color:var(--muted); font-size: 13px; line-height: 1.35; }
    .log{
      margin-top: 10px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(0,0,0,.15);
      color: var(--muted);
      font-size: 13px;
      min-height: 96px;
      white-space: pre-line;
    }
    .win{
      display:none;
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(57,217,138,.35);
      background: rgba(57,217,138,.10);
      color: var(--text);
      font-size: 13px;
      line-height: 1.35;
    }
    .miniCredit{
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size: 12.5px;
    }
    .miniCredit b{ color: var(--text); }

    @media (max-width: 900px){
      .main{ grid-template-columns: 1fr; }
      :root{ --cell: min(11.5vw, 56px); --gap: 5px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Damero ‚Äî Estrategia</h1>
        <p>T√∫ juegas <b>Oscuras</b>. Captura (‚Äúcome‚Äù) hacia adelante y hacia atr√°s. Si puedes comer, es obligatorio.</p>
        <div class="credit">‚úçÔ∏è <b>Por: Soamy Lanza, 2025</b></div>
      </div>
      <div class="panel">
        <select id="levelSel" aria-label="Nivel">
          <option value="low">Bajo</option>
          <option value="mid" selected>Medio</option>
          <option value="high">Alto</option>
        </select>
        <button id="btnNew" class="primary">Nuevo</button>
        <button id="btnRestart">Reiniciar</button>
        <button id="btnUndo">Limpiar</button>
        <button id="btnSolve" class="danger">Resolver</button>
      </div>
    </header>

    <section class="main">
      <div class="card">
        <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;">
          <div class="chip">‚è±Ô∏è Tiempo: <b id="time">00:00</b></div>
          <div class="chip">üîÅ Movs: <b id="moves">0</b></div>
          <div class="chip">‚≠ê Puntaje: <b id="score">0</b></div>
        </div>

        <div class="boardWrap" style="margin-top:12px;">
          <div id="board" class="board" role="application" aria-label="Tablero Damero"></div>
        </div>
      </div>

      <aside class="card side">
        <h2>Estado</h2>
        <p id="status">Tu turno. Selecciona una ficha oscura y juega.</p>

        <div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:8px;">
          <span class="chip">Oscuras: <b id="c1">12</b></span>
          <span class="chip">Claras: <b id="c2">12</b></span>
          <span class="chip">Turno: <b id="turn">Oscuras</b></span>
        </div>

        <div class="log" id="log"></div>
        <div class="win" id="winBox"></div>

        <div class="miniCredit">¬© <b>Por: Soamy Lanza, 2025</b></div>

        <p style="margin-top:10px;">
          Tips:
          <br>‚Ä¢ Si puedes <b>comer</b>, es obligatorio.
          <br>‚Ä¢ Comer en cadena (multi-salto) te da ventaja.
          <br>‚Ä¢ Corona: llega al borde contrario y ser√°s <b>Reina</b>.
        </p>
      </aside>
    </section>
  </div>

<script>
(() => {
  const EMPTY=0, P1=1, P2=2, K1=3, K2=4;

  const boardEl = document.getElementById("board");
  const statusEl = document.getElementById("status");
  const logEl = document.getElementById("log");
  const winBox = document.getElementById("winBox");

  const c1El = document.getElementById("c1");
  const c2El = document.getElementById("c2");
  const turnEl = document.getElementById("turn");
  const movesEl = document.getElementById("moves");
  const timeEl = document.getElementById("time");
  const scoreEl = document.getElementById("score");

  const levelSel = document.getElementById("levelSel");
  const btnNew = document.getElementById("btnNew");
  const btnRestart = document.getElementById("btnRestart");
  const btnUndo = document.getElementById("btnUndo");
  const btnSolve = document.getElementById("btnSolve");

  let B = new Array(64).fill(EMPTY);
  let turn = P1;
  let moves = 0;
  let score = 0;

  let sel = null;
  let legalForSel = [];
  let mustContinueFrom = null;

  const history = [];

  let started=false, seconds=0, timerId=null;

  const idx = (r,c)=> r*8+c;
  const rc = (i)=> [Math.floor(i/8), i%8];
  const inb = (r,c)=> r>=0 && r<8 && c>=0 && c<8;

  const isP1 = (v)=> v===P1 || v===K1;
  const isP2 = (v)=> v===P2 || v===K2;
  const isKing = (v)=> v===K1 || v===K2;

  function log(msg){
    logEl.textContent = (logEl.textContent ? (logEl.textContent+"\n") : "") + msg;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function formatTime(s){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }
  function startTimer(){
    if(started) return;
    started=true;
    timerId=setInterval(()=>{
      seconds++;
      timeEl.textContent=formatTime(seconds);
      updateScore();
    },1000);
  }
  function stopTimer(){
    if(timerId) clearInterval(timerId);
    timerId=null; started=false;
  }
  function resetTimer(){
    stopTimer(); seconds=0;
    timeEl.textContent="00:00";
  }

  function cloneBoard(b){ return b.slice(); }

  function pushHist(){
    history.push({
      B: cloneBoard(B),
      turn,
      moves,
      score,
      seconds,
      started,
      sel,
      mustContinueFrom
    });
  }
  function popHist(){
    const h = history.pop();
    if(!h) return false;
    B = cloneBoard(h.B);
    turn = h.turn;
    moves = h.moves;
    score = h.score;
    seconds = h.seconds;
    timeEl.textContent = formatTime(seconds);
    if(h.started){
      if(timerId) clearInterval(timerId);
      started=false;
      startTimer();
    }else{
      stopTimer(); started=false;
    }
    sel = h.sel;
    mustContinueFrom = h.mustContinueFrom;
    legalForSel = [];
    winBox.style.display="none";
    render();
    updateHUD();
    return true;
  }

  function setupInitial(){
    B.fill(EMPTY);
    for(let r=0;r<3;r++){
      for(let c=0;c<8;c++){
        if((r+c)%2===1) B[idx(r,c)] = P2;
      }
    }
    for(let r=5;r<8;r++){
      for(let c=0;c<8;c++){
        if((r+c)%2===1) B[idx(r,c)] = P1;
      }
    }
    turn=P1;
    moves=0;
    score=0;
    sel=null;
    mustContinueFrom=null;
    legalForSel=[];
    history.length=0;
    winBox.style.display="none";
    logEl.textContent="";
    resetTimer();
    render();
    updateHUD();
    log("Nuevo juego. T√∫: Oscuras. IA: Claras.");
  }

  function restartBoardKeepTimer(){
    B.fill(EMPTY);
    for(let r=0;r<3;r++) for(let c=0;c<8;c++) if((r+c)%2===1) B[idx(r,c)] = P2;
    for(let r=5;r<8;r++) for(let c=0;c<8;c++) if((r+c)%2===1) B[idx(r,c)] = P1;
    turn=P1;
    moves=0;
    sel=null;
    mustContinueFrom=null;
    legalForSel=[];
    history.length=0;
    winBox.style.display="none";
    render();
    updateHUD();
    log("Reiniciar: tablero restaurado (timer y puntaje se mantienen).");
  }

  // ‚Äúcoma para adelante y atr√°s‚Äù: capturas en todas direcciones.
  function moveDirs(piece){
    if(isKing(piece)) return [[-1,-1],[-1,1],[1,-1],[1,1]];
    return (isP1(piece)) ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
  }
  function captureDirs(_piece){
    return [[-1,-1],[-1,1],[1,-1],[1,1]];
  }

  function movesFrom(b, from){
    const piece = b[from];
    if(piece===EMPTY) return [];
    const player = isP1(piece) ? P1 : P2;
    const oppCheck = (player===P1) ? isP2 : isP1;
    const [r,c] = rc(from);

    const caps = [];
    for(const [dr,dc] of captureDirs(piece)){
      const r1=r+dr, c1=c+dc;
      const r2=r+2*dr, c2=c+2*dc;
      if(!inb(r2,c2)) continue;
      const mid = idx(r1,c1), to = idx(r2,c2);
      if(oppCheck(b[mid]) && b[to]===EMPTY){
        caps.push({ from, to, captures:[mid], isCapture:true });
      }
    }
    if(caps.length) return caps;

    const steps = [];
    for(const [dr,dc] of moveDirs(piece)){
      const rr=r+dr, cc=c+dc;
      if(!inb(rr,cc)) continue;
      const to=idx(rr,cc);
      if(b[to]===EMPTY){
        steps.push({from,to,captures:[],isCapture:false});
      }
    }
    return steps;
  }

  function allMovesForPlayer(b, player){
    const out = [];
    for(let i=0;i<64;i++){
      const v = b[i];
      if(player===P1 && !isP1(v)) continue;
      if(player===P2 && !isP2(v)) continue;
      out.push(...movesFrom(b, i));
    }
    return out;
  }

  function mustCaptureMoves(b, player){
    const all = allMovesForPlayer(b, player);
    const caps = all.filter(m=>m.isCapture);
    return {all, caps, mustCapture: caps.length>0};
  }

  function applyMove(b, m){
    const nb = b.slice();
    let piece = nb[m.from];
    nb[m.from]=EMPTY;
    nb[m.to]=piece;
    for(const cap of m.captures) nb[cap]=EMPTY;

    const [tr] = rc(m.to);
    if(piece===P1 && tr===0) nb[m.to]=K1;
    if(piece===P2 && tr===7) nb[m.to]=K2;

    return nb;
  }

  function nextCapturesFrom(b, pos){
    const piece = b[pos];
    const oppCheck = isP1(piece) ? isP2 : isP1;
    const [r,c] = rc(pos);
    const caps = [];
    for(const [dr,dc] of captureDirs(piece)){
      const r1=r+dr, c1=c+dc;
      const r2=r+2*dr, c2=c+2*dc;
      if(!inb(r2,c2)) continue;
      const mid=idx(r1,c1), to=idx(r2,c2);
      if(oppCheck(b[mid]) && b[to]===EMPTY){
        caps.push({from:pos,to,captures:[mid],isCapture:true});
      }
    }
    return caps;
  }

  // IA
  function aiDepth(){
    const lvl = levelSel.value;
    if(lvl==="low") return 2;
    if(lvl==="mid") return 4;
    return 6;
  }

  function evalBoard(b){
    let p1=0,p2=0,k1=0,k2=0;
    for(const v of b){
      if(v===P1) p1++;
      else if(v===P2) p2++;
      else if(v===K1) k1++;
      else if(v===K2) k2++;
    }
    const material = (p1 - p2) * 10 + (k1 - k2) * 18;
    const mob1 = allMovesForPlayer(b, P1).length;
    const mob2 = allMovesForPlayer(b, P2).length;
    const mobility = (mob1 - mob2) * 0.6;
    const caps1 = allMovesForPlayer(b, P1).filter(m=>m.isCapture).length;
    const caps2 = allMovesForPlayer(b, P2).filter(m=>m.isCapture).length;
    const threat = (caps1 - caps2) * 1.1;
    return material + mobility + threat;
  }

  function isTerminal(b){
    const m1 = allMovesForPlayer(b,P1).length;
    const m2 = allMovesForPlayer(b,P2).length;
    let a=0,b2=0;
    for(const v of b){
      if(isP1(v)) a++;
      else if(isP2(v)) b2++;
    }
    return a===0 || b2===0 || m1===0 || m2===0;
  }

  function promotes(b, m){
    const piece = b[m.from];
    const [tr] = rc(m.to);
    return (piece===P1 && tr===0) || (piece===P2 && tr===7);
  }

  function applyForcedMulti(b, startPos){
    let nb = b.slice();
    let pos = startPos;
    while(true){
      const caps = nextCapturesFrom(nb, pos);
      if(!caps.length) break;
      let best = caps[0], bestVal = -Infinity;
      for(const m of caps){
        const tb = applyMove(nb, m);
        const v = evalBoard(tb);
        if(v > bestVal){ bestVal=v; best=m; }
      }
      nb = applyMove(nb, best);
      pos = best.to;
    }
    return nb;
  }

  function minimax(b, player, depth, alpha, beta){
    if(depth===0 || isTerminal(b)) return {score: evalBoard(b), best:null};

    const {all, caps, mustCapture} = mustCaptureMoves(b, player);
    let list = (mustCapture ? caps : all).slice();

    list.sort((a,bm)=>{
      const aK = promotes(b, a) ? 1 : 0;
      const bK = promotes(b, bm) ? 1 : 0;
      return (bm.isCapture - a.isCapture) + (bK - aK);
    });

    if(!list.length) return {score: evalBoard(b), best:null};

    if(player===P1){
      let bestScore=-Infinity, best=null;
      for(const m of list){
        let nb = applyMove(b, m);
        if(m.isCapture) nb = applyForcedMulti(nb, m.to);
        const r = minimax(nb, P2, depth-1, alpha, beta);
        if(r.score > bestScore){ bestScore=r.score; best=m; }
        alpha = Math.max(alpha, bestScore);
        if(beta <= alpha) break;
      }
      return {score: bestScore, best};
    }else{
      let bestScore=Infinity, best=null;
      for(const m of list){
        let nb = applyMove(b, m);
        if(m.isCapture) nb = applyForcedMulti(nb, m.to);
        const r = minimax(nb, P1, depth-1, alpha, beta);
        if(r.score < bestScore){ bestScore=r.score; best=m; }
        beta = Math.min(beta, bestScore);
        if(beta <= alpha) break;
      }
      return {score: bestScore, best};
    }
  }

  function counts(){
    let a=0,b=0;
    for(const v of B){
      if(isP1(v)) a++;
      else if(isP2(v)) b++;
    }
    return {a,b};
  }

  function updateScore(final=false){
    const {a,b} = counts();
    let k1=0,k2=0;
    for(const v of B){ if(v===K1) k1++; else if(v===K2) k2++; }
    let s = (a-b)*35 + (k1-k2)*55 - Math.floor(seconds*0.7) - moves*2;
    if(final){
      if(a>b) s += 250;
      else if(a<b) s -= 120;
    }
    score = Math.max(0, Math.floor(s));
    scoreEl.textContent = score;
  }

  function setStatus(){
    const {a,b} = counts();
    c1El.textContent = a;
    c2El.textContent = b;
    turnEl.textContent = (turn===P1) ? "Oscuras" : "Claras";

    if(isTerminal(B)){
      stopTimer();
      const m1 = allMovesForPlayer(B,P1).length;
      const m2 = allMovesForPlayer(B,P2).length;
      let msg="";
      if(a===0 || m1===0) msg="Fin: Gan√≥ la IA (Claras).";
      else if(b===0 || m2===0) msg="Fin: ¬°Ganaste! (Oscuras).";
      else msg="Fin: Empate t√©cnico.";
      winBox.style.display="block";
      winBox.textContent = msg;
      statusEl.textContent = "Juego terminado.";
      updateScore(true);
      return;
    }

    if(mustContinueFrom!=null && turn===P1){
      statusEl.textContent = "Multi-captura: debes seguir comiendo con la misma ficha.";
    }else{
      statusEl.textContent = (turn===P1) ? "Tu turno (Oscuras)." : "Turno de la IA (Claras).";
    }
    updateScore();
  }

  function clearHighlights(){
    sel=null;
    legalForSel=[];
    [...boardEl.children].forEach(el=>{
      el.classList.remove("sel","move","capture");
    });
  }

  function computeLegalForSelection(from){
    const piece = B[from];
    if(piece===EMPTY) return [];
    if(turn===P1 && !isP1(piece)) return [];
    if(turn===P2 && !isP2(piece)) return [];
    if(mustContinueFrom!=null && from!==mustContinueFrom) return [];

    const {all, caps, mustCapture} = mustCaptureMoves(B, turn);
    const candidate = movesFrom(B, from);
    return mustCapture ? candidate.filter(m=>m.isCapture) : candidate;
  }

  function doMove(m){
    pushHist();
    if(!started) startTimer();

    const wasCapture = m.isCapture;
    B = applyMove(B, m);
    moves++;

    if(wasCapture){
      score = Math.max(0, score + 40 + (m.captures.length*20));
      scoreEl.textContent = score;
    }

    if(wasCapture){
      const more = nextCapturesFrom(B, m.to);
      if(more.length){
        mustContinueFrom = m.to;
        sel = m.to;
        legalForSel = computeLegalForSelection(sel);
        render();
        updateHUD();
        log("Comiste. Puedes seguir comiendo (obligatorio).");
        return;
      }
    }

    mustContinueFrom = null;
    turn = (turn===P1) ? P2 : P1;
    clearHighlights();
    render();
    updateHUD();

    if(turn===P2) window.setTimeout(aiTurn, 120);
  }

  function aiTurn(){
    if(turn!==P2) return;
    if(isTerminal(B)) { setStatus(); return; }

    const depth = aiDepth();
    const res = minimax(B, P2, depth, -Infinity, Infinity);
    let m = res.best;

    const {all, caps, mustCapture} = mustCaptureMoves(B, P2);
    const list = mustCapture ? caps : all;
    if(!m && list.length) m = list[0];
    if(!m){ setStatus(); return; }

    doMove(m);

    while(turn===P2 && mustContinueFrom!=null){
      const caps2 = nextCapturesFrom(B, mustContinueFrom);
      if(!caps2.length){ mustContinueFrom=null; break; }
      let best=caps2[0], bestVal=Infinity;
      for(const mm of caps2){
        const tb = applyMove(B, mm);
        const v = evalBoard(tb);
        if(v < bestVal){ bestVal=v; best=mm; }
      }
      doMove(best);
    }
  }

  function pretty(i){
    const [r,c]=rc(i);
    const L="ABCDEFGH"[c];
    return `${L}${8-r}`;
  }

  function solveHint(){
    if(turn!==P1) return;
    const depth = Math.max(2, aiDepth());
    const res = minimax(B, P1, depth, -Infinity, Infinity);
    const m = res.best;
    if(!m){ log("No hay jugadas disponibles."); return; }

    clearHighlights();
    sel = m.from;
    legalForSel = computeLegalForSelection(sel);
    render();

    const cell = boardEl.querySelector(`[data-i="${m.to}"]`);
    if(cell){
      cell.classList.add(m.isCapture ? "capture" : "move");
      cell.classList.add("sel");
    }
    log(`Sugerencia: ${pretty(m.from)} ‚Üí ${pretty(m.to)}${m.isCapture ? " (come)" : ""}.`);
  }

  function updateHUD(){
    movesEl.textContent = moves;
    scoreEl.textContent = score;
    setStatus();
  }

  function render(){
    boardEl.innerHTML="";
    for(let i=0;i<64;i++){
      const [r,c]=rc(i);
      const cell=document.createElement("div");
      cell.className="cell " + (((r+c)%2===0) ? "light":"dark");
      cell.setAttribute("data-i", i);

      const v=B[i];
      if(v!==EMPTY){
        const p=document.createElement("div");
        p.className="piece " + (isP1(v) ? "p1":"p2");
        if(isKing(v)){
          const k=document.createElement("div");
          k.className="kingMark";
          k.textContent="K";
          p.appendChild(k);
        }
        cell.appendChild(p);
      }

      if(sel===i) cell.classList.add("sel");
      if(sel!=null && legalForSel.some(m=>m.to===i)){
        const mm = legalForSel.find(m=>m.to===i);
        cell.classList.add(mm.isCapture ? "capture" : "move");
      }

      cell.addEventListener("click", ()=>onCell(i));
      boardEl.appendChild(cell);
    }

    updateHUD();
    btnUndo.disabled = history.length===0;
    btnSolve.disabled = (turn!==P1) || isTerminal(B);
  }

  function onCell(i){
    if(isTerminal(B)) return;
    if(turn!==P1) return;

    const v=B[i];

    if(sel!=null){
      const m = legalForSel.find(x=>x.to===i);
      if(m){ doMove(m); return; }
    }

    if(isP1(v)){
      sel=i;
      legalForSel = computeLegalForSelection(sel);
      if(legalForSel.length===0){
        const {mustCapture} = mustCaptureMoves(B, P1);
        if(mustCapture) log("Tienes captura obligatoria, pero no con esa ficha.");
      }
      render();
      return;
    }

    clearHighlights();
    render();
  }

  btnNew.addEventListener("click", ()=> setupInitial());
  btnRestart.addEventListener("click", ()=> {
    if(!started) startTimer(); // opcional: si quieres que al reiniciar siga corriendo
    restartBoardKeepTimer();
  });
  btnUndo.addEventListener("click", ()=>{
    const ok = popHist();
    if(!ok) log("Nada que deshacer.");
  });
  btnSolve.addEventListener("click", ()=> solveHint());
  levelSel.addEventListener("change", ()=>{
    log(`Nivel: ${levelSel.options[levelSel.selectedIndex].text}.`);
  });

  setupInitial();
})();
</script>
</body>
</html>
