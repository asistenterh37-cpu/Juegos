<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Torres de Han√≥i ‚Äî Razonamiento</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#101a2f;
      --card2:#0f1830;
      --text:#e9eefc;
      --muted:#a9b4d0;
      --accent:#6ee7ff;
      --ok:#39d98a;
      --warn:#ffd166;
      --bad:#ff5c7a;
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --pegW: min(30vw, 240px);
      --pegH: min(44vh, 360px);
      --diskH: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(900px 500px at 20% 10%, #18305c 0%, transparent 60%),
                  radial-gradient(900px 600px at 90% 30%, #0d3b4a 0%, transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 18px;
    }

    .wrap{
      width:min(1100px, 100%);
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    header{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.09);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: var(--shadow);
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 260px;
    }
    .title h1{
      font-size: 18px;
      margin:0;
      letter-spacing:.2px;
    }
    .title p{
      margin:0;
      color:var(--muted);
      font-size: 13px;
    }

    .panel{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }

    .chip{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size: 13px;
      color: var(--muted);
    }
    .chip b{ color: var(--text); font-weight: 700; }

    select, button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    select{
      padding-right: 34px;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(233,238,252,.9) 50%),
        linear-gradient(135deg, rgba(233,238,252,.9) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) 55%,
        calc(100% - 12px) 55%;
      background-size: 6px 6px, 6px 6px;
      background-repeat:no-repeat;
    }
    button:hover, select:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18); }
    button:active, select:active{ transform: scale(.98); }
    button.primary{
      border-color: rgba(110,231,255,.35);
      box-shadow: 0 0 0 0 rgba(110,231,255,.35);
    }
    button.danger{
      border-color: rgba(255,92,122,.35);
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    .game{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.09);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .status{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }

    .hint{
      color:var(--muted);
      font-size: 13px;
      line-height: 1.25;
    }
    .hint .picked{
      color: var(--accent);
      font-weight: 700;
    }

    .board{
      display:flex;
      gap: 12px;
      justify-content:space-between;
      align-items:stretch;
      width:100%;
    }

    .peg{
      flex:1;
      min-width: 0;
      background: rgba(16,26,47,.55);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px;
      padding: 12px;
      position:relative;
      display:flex;
      flex-direction:column;
      justify-content:flex-end;
      height: var(--pegH);
      cursor:pointer;
      overflow:hidden;
      touch-action: manipulation;
    }
    .peg:focus{ outline: none; }
    .peg.selected{
      border-color: rgba(110,231,255,.45);
      box-shadow: 0 0 0 3px rgba(110,231,255,.12) inset;
    }

    .rod{
      position:absolute;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      width: 8px;
      height: calc(var(--pegH) - 40px);
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(233,238,252,.55), rgba(233,238,252,.12));
      opacity:.55;
      pointer-events:none;
    }
    .base{
      position:absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      height: 10px;
      border-radius: 999px;
      background: rgba(233,238,252,.10);
      pointer-events:none;
    }

    .disk{
      height: var(--diskH);
      border-radius: 12px;
      margin: 5px auto 0 auto;
      border: 1px solid rgba(255,255,255,.16);
      background: linear-gradient(180deg, rgba(110,231,255,.35), rgba(110,231,255,.10));
      box-shadow: 0 10px 18px rgba(0,0,0,.22);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      color: rgba(233,238,252,.88);
      letter-spacing:.2px;
    }
    .disk.small { background: linear-gradient(180deg, rgba(57,217,138,.40), rgba(57,217,138,.10)); }
    .disk.med   { background: linear-gradient(180deg, rgba(255,209,102,.40), rgba(255,209,102,.10)); }
    .disk.big   { background: linear-gradient(180deg, rgba(255,92,122,.40), rgba(255,92,122,.10)); }

    .footerRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }

    .msg{
      font-size: 13px;
      color: var(--muted);
    }
    .msg strong{ color: var(--text); }

    /* Mobile tweaks */
    @media (max-width: 720px){
      :root{ --pegH: min(46vh, 320px); --diskH: 14px; }
      header{ gap:10px; }
      .panel{ justify-content:flex-start; }
      .board{ gap:10px; }
      .title{ min-width: 0; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Torres de Han√≥i ‚Äî prueba de razonamiento</h1>
        <p>Nivel + planificaci√≥n + control de errores. Toca una torre para tomar y toca otra para soltar.</p>
      </div>

      <div class="panel">
        <select id="levelSel" aria-label="Nivel">
          <option value="low">Bajo (4 discos)</option>
          <option value="mid" selected>Medio (6 discos)</option>
          <option value="high">Alto (8 discos)</option>
        </select>
        <button id="btnNew" class="primary">Nuevo</button>
        <button id="btnRestart">Reiniciar</button>
        <button id="btnClear">Limpiar</button>
        <button id="btnSolve" class="danger">Resolver</button>
      </div>
    </header>

    <section class="game">
      <div class="status">
        <div class="chip" title="Cron√≥metro">
          ‚è±Ô∏è <span>Tiempo:</span> <b id="time">00:00</b>
        </div>
        <div class="chip" title="Movimientos y √≥ptimo">
          üîÅ <span>Movs:</span> <b id="moves">0</b> <span style="opacity:.8">/ √ìptimo:</span> <b id="optimal">0</b>
        </div>
        <div class="chip" title="Puntaje (m√°s alto es mejor)">
          üèÅ <span>Puntaje:</span> <b id="score">0</b>
        </div>
      </div>

      <div class="hint" id="hint">
        Tip: si te atoras, piensa en ‚Äúmover la torre de arriba‚Äù (recursi√≥n). <span id="pickedInfo"></span>
      </div>

      <div class="board" role="application" aria-label="Tablero Torres de Han√≥i">
        <div class="peg" id="peg0" tabindex="0" aria-label="Torre A">
          <div class="rod"></div><div class="base"></div>
        </div>
        <div class="peg" id="peg1" tabindex="0" aria-label="Torre B">
          <div class="rod"></div><div class="base"></div>
        </div>
        <div class="peg" id="peg2" tabindex="0" aria-label="Torre C">
          <div class="rod"></div><div class="base"></div>
        </div>
      </div>

      <div class="footerRow">
        <div class="msg" id="msg">
          Objetivo: mover todos los discos a la torre C respetando que un disco grande nunca vaya sobre uno peque√±o.
        </div>
        <div class="msg" id="winMsg" style="display:none;">
          ‚úÖ <strong>¬°Resuelto!</strong> Buen cerebro. (Y s√≠: tu CPU interna se calent√≥ un poquito.)
        </div>
      </div>
    </section>
  </div>

<script>
(() => {
  // ----- State -----
  const pegsEl = [peg0, peg1, peg2];
  let pegs = [[], [], []];     // each peg is array of disk sizes (1..n), bottom->top? We'll store bottom->top for easy render.
  let nDisks = 6;
  let pickedFrom = null;       // peg index selected
  let moves = 0;
  let started = false;
  let timerId = null;
  let seconds = 0;
  let solving = false;
  let solveQueue = [];
  let solveId = null;

  // ----- UI refs -----
  const timeEl = document.getElementById('time');
  const movesEl = document.getElementById('moves');
  const optimalEl = document.getElementById('optimal');
  const scoreEl = document.getElementById('score');
  const msgEl = document.getElementById('msg');
  const winEl = document.getElementById('winMsg');
  const pickedInfo = document.getElementById('pickedInfo');

  const levelSel = document.getElementById('levelSel');
  const btnNew = document.getElementById('btnNew');
  const btnRestart = document.getElementById('btnRestart');
  const btnClear = document.getElementById('btnClear');
  const btnSolve = document.getElementById('btnSolve');

  // ----- Helpers -----
  function optimalMoves(n){ return (1 << n) - 1; }

  function formatTime(s){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function setMessage(text, tone=""){
    msgEl.innerHTML = text;
    msgEl.style.color = tone === "bad" ? "var(--bad)" : "var(--muted)";
  }

  function resetTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null;
    seconds = 0;
    started = false;
    timeEl.textContent = formatTime(0);
  }

  function startTimer(){
    if(started) return;
    started = true;
    timerId = setInterval(() => {
      seconds++;
      timeEl.textContent = formatTime(seconds);
      updateScore();
    }, 1000);
  }

  function stopTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null;
    started = false;
  }

  function updateScore(){
    // Score tries to be fair across levels:
    // base increases with disks; penalties for extra moves and time.
    const opt = optimalMoves(nDisks);
    const extra = Math.max(0, moves - opt);
    const base = 400 + nDisks * 120; // more disks => higher potential score
    const penalty = extra * (18 + nDisks) + seconds * 2;
    const raw = Math.max(0, Math.round(base - penalty));
    scoreEl.textContent = raw;
  }

  function clearSelection(){
    pickedFrom = null;
    pegsEl.forEach(p => p.classList.remove('selected'));
    pickedInfo.textContent = '';
  }

  function topDisk(pegIndex){
    const arr = pegs[pegIndex];
    return arr.length ? arr[arr.length - 1] : null;
  }

  function canMove(from, to){
    const a = topDisk(from);
    if(a === null) return false;
    const b = topDisk(to);
    return b === null || a < b;
  }

  function applyMove(from, to, countMove=true){
    if(!canMove(from, to)) return false;
    const disk = pegs[from].pop();
    pegs[to].push(disk);
    if(countMove){
      moves++;
      movesEl.textContent = moves;
      updateScore();
    }
    render();
    checkWin();
    return true;
  }

  function checkWin(){
    const won = pegs[2].length === nDisks;
    if(won){
      winEl.style.display = 'block';
      setMessage('Objetivo cumplido: todos los discos llegaron a la torre C. Ahora s√≠: tu l√≥bulo frontal puede celebrar üß†‚ú®');
      stopTimer();
      solving = false;
      btnSolve.disabled = false;
      btnNew.disabled = false;
      btnRestart.disabled = false;
      btnClear.disabled = false;
    }
  }

  function diskClass(size){
    if(size <= Math.ceil(nDisks/3)) return "small";
    if(size <= Math.ceil(2*nDisks/3)) return "med";
    return "big";
  }

  function render(){
    // Clear old disks
    pegsEl.forEach((pegEl) => {
      // Keep rod/base; remove disks only
      [...pegEl.querySelectorAll('.disk')].forEach(d => d.remove());
    });

    // Render disks
    for(let i=0;i<3;i++){
      const arr = pegs[i]; // bottom->top
      arr.forEach((size) => {
        const d = document.createElement('div');
        d.className = `disk ${diskClass(size)}`;
        d.textContent = size;
        // width proportional: smallest ~35%, largest ~95%
        const minW = 38, maxW = 96;
        const w = minW + (maxW - minW) * (size - 1) / (nDisks - 1 || 1);
        d.style.width = `${w}%`;
        pegsEl[i].appendChild(d);
      });
    }
  }

  function newGame(){
    stopSolving();
    clearSelection();
    winEl.style.display = 'none';

    const lvl = levelSel.value;
    nDisks = (lvl === 'low') ? 4 : (lvl === 'mid') ? 6 : 8;

    pegs = [[], [], []];
    // Put all disks on peg 0 (A), bottom->top: n..1
    for(let s = nDisks; s >= 1; s--) pegs[0].push(s);

    moves = 0;
    movesEl.textContent = moves;
    optimalEl.textContent = optimalMoves(nDisks);
    resetTimer();
    updateScore();
    render();
    setMessage('Listo. Primer movimiento inicia el cron√≥metro. Tip: si tu plan es ‚Äúa ver qu√© sale‚Äù, Han√≥i se r√≠e en tu cara üòÖ');
  }

  function restartGame(){
    // reset to initial layout same level, reset timer/moves
    const currentLevel = levelSel.value;
    newGame();
    levelSel.value = currentLevel; // keep selected
    // newGame() already uses current selection, so this is safe.
  }

  function limparAction(){
    // "Limpiar" here = Deshacer el √∫ltimo movimiento (y cancela selecci√≥n/solver).
    stopSolving();
    clearSelection();
    // Undo by storing history? We'll implement light undo by keeping a stack.
    if(history.length === 0){
      setMessage('Nada que limpiar. (Todav√≠a üòÑ)');
      return;
    }
    const last = history.pop();
    // reverse move without counting as a move
    applyMove(last.to, last.from, false);
    moves = Math.max(0, moves - 1);
    movesEl.textContent = moves;
    updateScore();
    if(!started && moves > 0) startTimer(); // rare case
    winEl.style.display = 'none';
    setMessage('Movimiento deshecho. Limpiar tambi√©n es una habilidad: se llama ‚Äúcontrol de da√±os‚Äù üòå');
  }

  // ----- Move History for Undo -----
  const history = [];

  function userMove(from, to){
    if(solving) return;
    if(!started) startTimer();
    const ok = applyMove(from, to, true);
    if(ok){
      history.push({from, to});
      setMessage('Buen movimiento. (Tu yo del futuro te lo agradece).');
    }else{
      setMessage('Movimiento inv√°lido: un disco grande no puede ir sobre uno peque√±o.', 'bad');
    }
  }

  // ----- Input handling -----
  function onPegTap(pegIndex){
    if(solving) return;

    // If nothing selected: select if peg has a disk
    if(pickedFrom === null){
      if(topDisk(pegIndex) === null){
        setMessage('Esa torre est√° vac√≠a. Intenta con una que tenga disco.');
        return;
      }
      pickedFrom = pegIndex;
      pegsEl[pegIndex].classList.add('selected');
      pickedInfo.innerHTML = `Seleccionado: <span class="picked">Torre ${pegName(pegIndex)}</span>`;
      return;
    }

    // If selected same peg: deselect
    if(pickedFrom === pegIndex){
      clearSelection();
      setMessage('Selecci√≥n cancelada. Respira. Decide. Domina.');
      return;
    }

    // Otherwise, attempt move
    const from = pickedFrom;
    const to = pegIndex;
    clearSelection();
    userMove(from, to);
  }

  function pegName(i){ return i === 0 ? 'A' : i === 1 ? 'B' : 'C'; }

  pegsEl.forEach((el, idx) => {
    el.addEventListener('click', () => onPegTap(idx));
    el.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        onPegTap(idx);
      }
    });
  });

  // ----- Solver -----
  function generateSolution(n, from, aux, to, out){
    if(n <= 0) return;
    generateSolution(n-1, from, to, aux, out);
    out.push([from, to]);
    generateSolution(n-1, aux, from, to, out);
  }

  function stopSolving(){
    solving = false;
    solveQueue = [];
    if(solveId) clearInterval(solveId);
    solveId = null;
    btnSolve.textContent = 'Resolver';
    btnSolve.disabled = false;
    btnNew.disabled = false;
    btnRestart.disabled = false;
    btnClear.disabled = false;
  }

  function solveFromStart(){
    // as requested: resolver (reinicia y resuelve)
    restartGame();
    history.length = 0;

    solving = true;
    btnSolve.textContent = 'Resolviendo‚Ä¶';
    btnNew.disabled = true;
    btnRestart.disabled = true;
    btnClear.disabled = true;

    solveQueue = [];
    generateSolution(nDisks, 0, 1, 2, solveQueue);

    // Start timer now for a fair "demo" (or comment out if you want solver not to affect timer)
    if(!started) startTimer();

    const speedMs = (nDisks <= 4) ? 220 : (nDisks <= 6) ? 160 : 120;

    solveId = setInterval(() => {
      if(!solving) return;
      const step = solveQueue.shift();
      if(!step){
        stopSolving();
        setMessage('Solver terminado. Si quieres sufrir con dignidad: juega en Alto üòà');
        return;
      }
      const [from, to] = step;
      // count solver moves too
      applyMove(from, to, true);
      history.push({from, to});
    }, speedMs);
  }

  // ----- Buttons -----
  btnNew.addEventListener('click', () => {
    history.length = 0;
    newGame();
  });

  btnRestart.addEventListener('click', () => {
    history.length = 0;
    restartGame();
  });

  btnClear.addEventListener('click', () => {
    limparAction();
  });

  btnSolve.addEventListener('click', () => {
    if(solving){
      stopSolving();
      setMessage('Solver detenido.');
    }else{
      solveFromStart();
    }
  });

  levelSel.addEventListener('change', () => {
    history.length = 0;
    newGame();
  });

  // ----- Boot -----
  newGame();
})();
</script>
</body>
</html>
