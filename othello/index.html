<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Othello (Reversi) ‚Äî Estrategia</title>
  <style>
    :root{
      --bg:#0b1220;
      --card: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.10);
      --text:#e9eefc;
      --muted:#a9b4d0;
      --accent:#6ee7ff;
      --good:#39d98a;
      --warn:#ffd166;
      --bad:#ff5c7a;
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --r: 18px;
      --cell: min(10.5vw, 56px);
      --gap: 6px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 20% 10%, #18305c 0%, transparent 60%),
        radial-gradient(900px 600px at 90% 30%, #0d3b4a 0%, transparent 55%),
        var(--bg);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 18px;
    }
    .wrap{ width:min(1100px, 100%); display:flex; flex-direction:column; gap:14px; }

    header{
      display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:space-between;
      background: var(--card);
      border:1px solid var(--border);
      border-radius: var(--r);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title{ display:flex; flex-direction:column; gap:2px; min-width:280px; }
    .title h1{ margin:0; font-size: 18px; letter-spacing:.2px; }
    .title p{ margin:0; font-size: 13px; color:var(--muted); }

    .panel{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-end; }

    .chip{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
    }
    .chip b{ color:var(--text); font-weight: 800; }

    select, button{
      appearance:none;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    select{
      padding-right: 34px;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(233,238,252,.9) 50%),
        linear-gradient(135deg, rgba(233,238,252,.9) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) 55%,
        calc(100% - 12px) 55%;
      background-size: 6px 6px, 6px 6px;
      background-repeat:no-repeat;
    }
    button:hover, select:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18); }
    button:active, select:active{ transform: scale(.98); }
    button.primary{ border-color: rgba(110,231,255,.35); }
    button.danger{ border-color: rgba(255,92,122,.35); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .main{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 14px;
      align-items:start;
    }

    .card{
      background: var(--card);
      border:1px solid var(--border);
      border-radius: var(--r);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    .boardWrap{ display:flex; justify-content:center; }
    .board{
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--gap);
      padding: 12px;
      background: rgba(16,26,47,.55);
      border:1px solid rgba(255,255,255,.09);
      border-radius: 18px;
      width: fit-content;
      max-width: 100%;
      overflow:auto;
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(120px 80px at 40% 20%, rgba(110,231,255,.12), transparent 55%),
        rgba(9, 90, 57, .45);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      cursor:pointer;
      touch-action: manipulation;
    }

    .cell.valid::after{
      content:"";
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: rgba(110,231,255,.85);
      box-shadow: 0 0 0 6px rgba(110,231,255,.12);
      position:absolute;
      opacity:.9;
    }

    .cell.hint{
      outline: 3px solid rgba(255,209,102,.65);
      box-shadow: 0 0 0 6px rgba(255,209,102,.14);
    }

    .disc{
      width: 78%;
      height: 78%;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 20px rgba(0,0,0,.30);
      transform: translateZ(0);
    }
    .disc.black{
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), transparent 45%),
                  linear-gradient(180deg, rgba(80,92,120,.35), rgba(0,0,0,.55));
    }
    .disc.white{
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.85), rgba(255,255,255,.25) 55%, rgba(255,255,255,.08));
      border-color: rgba(255,255,255,.35);
    }

    .side h2{ margin:0 0 8px 0; font-size: 16px; }
    .side p{ margin:0 0 10px 0; color:var(--muted); font-size: 13px; line-height: 1.35; }
    .log{
      margin-top: 10px;
      padding: 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(0,0,0,.15);
      color: var(--muted);
      font-size: 13px;
      min-height: 96px;
      white-space: pre-line;
    }

    .row{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
      margin-top: 10px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
    }
    .dot{ width:10px; height:10px; border-radius:999px; }
    .dot.b{ background: rgba(0,0,0,.70); border:1px solid rgba(255,255,255,.25); }
    .dot.w{ background: rgba(255,255,255,.80); border:1px solid rgba(255,255,255,.35); }

    .win{
      display:none;
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(57,217,138,.35);
      background: rgba(57,217,138,.10);
      color: var(--text);
      font-size: 13px;
      line-height: 1.35;
    }

    @media (max-width: 900px){
      .main{ grid-template-columns: 1fr; }
      :root{ --cell: min(11.5vw, 52px); --gap: 5px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Othello (Reversi) ‚Äî Estrategia</h1>
        <p>Tu juegas <b>Negro</b>. Ganas con m√°s fichas al final. Esquinas = oro.</p>
      </div>
      <div class="panel">
        <select id="levelSel" aria-label="Nivel">
          <option value="low">Bajo</option>
          <option value="mid" selected>Medio</option>
          <option value="high">Alto</option>
        </select>
        <button id="btnNew" class="primary">Nuevo</button>
        <button id="btnRestart">Reiniciar</button>
        <button id="btnUndo">Limpiar</button>
        <button id="btnHint" class="danger">Resolver</button>
      </div>
    </header>

    <section class="main">
      <div class="card">
        <div class="row">
          <div class="chip">‚è±Ô∏è Tiempo: <b id="time">00:00</b></div>
          <div class="chip">üîÅ Movs: <b id="moves">0</b></div>
          <div class="chip">üèÅ Puntaje: <b id="score">0</b></div>
        </div>
        <div class="boardWrap" style="margin-top:12px;">
          <div id="board" class="board" role="application" aria-label="Tablero Othello"></div>
        </div>
      </div>

      <aside class="card side">
        <h2>Estado</h2>
        <p id="status">Tu turno (Negro). Busca jugadas que tomen esquinas y no regales las ‚ÄúX‚Äù.</p>

        <div class="row">
          <span class="badge"><span class="dot b"></span> Negro: <b id="bCount">2</b></span>
          <span class="badge"><span class="dot w"></span> Blanco: <b id="wCount">2</b></span>
          <span class="badge">Turno: <b id="turn">Negro</b></span>
        </div>

        <div class="log" id="log"></div>

        <div class="win" id="winBox"></div>

        <p style="margin-top:10px;">
          Tips r√°pidos:
          <br>‚Ä¢ Las <b>esquinas</b> valen much√≠simo.
          <br>‚Ä¢ Evita la ‚ÄúX‚Äù (casillas diagonales a la esquina) si la esquina est√° libre.
          <br>‚Ä¢ No siempre conviene comer muchas fichas; a veces conviene <i>controlar</i>.
        </p>
      </aside>
    </section>
  </div>

<script>
(() => {
  // 0 vac√≠o, 1 negro (jugador), -1 blanco (IA)
  const EMPTY = 0, BLACK = 1, WHITE = -1;
  const DIRS = [
    [-1,-1], [-1,0], [-1,1],
    [0,-1],          [0,1],
    [1,-1],  [1,0],  [1,1]
  ];

  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const logEl = document.getElementById('log');
  const winBox = document.getElementById('winBox');

  const bCountEl = document.getElementById('bCount');
  const wCountEl = document.getElementById('wCount');
  const turnEl = document.getElementById('turn');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const scoreEl = document.getElementById('score');

  const levelSel = document.getElementById('levelSel');
  const btnNew = document.getElementById('btnNew');
  const btnRestart = document.getElementById('btnRestart');
  const btnUndo = document.getElementById('btnUndo');
  const btnHint = document.getElementById('btnHint');

  let board = new Array(64).fill(EMPTY);
  let turn = BLACK; // jugador inicia
  let moves = 0;

  let started = false, timerId = null, seconds = 0;

  // Historial para deshacer (guardamos snapshot)
  const history = [];

  // UI: hint cell
  let hintIndex = null;

  function idx(r,c){ return r*8 + c; }
  function rc(i){ return [Math.floor(i/8), i%8]; }
  function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

  function formatTime(s){
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }
  function resetTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null; seconds = 0; started = false;
    timeEl.textContent = "00:00";
  }
  function startTimer(){
    if(started) return;
    started = true;
    timerId = setInterval(() => {
      seconds++;
      timeEl.textContent = formatTime(seconds);
      updateScore();
    }, 1000);
  }
  function stopTimer(){
    if(timerId) clearInterval(timerId);
    timerId = null; started = false;
  }

  function cloneBoard(b){ return b.slice(); }

  function initBoard(){
    board.fill(EMPTY);
    // posici√≥n inicial
    board[idx(3,3)] = WHITE;
    board[idx(3,4)] = BLACK;
    board[idx(4,3)] = BLACK;
    board[idx(4,4)] = WHITE;
    turn = BLACK;
    moves = 0;
    history.length = 0;
    hintIndex = null;
    winBox.style.display = "none";
    logEl.textContent = "";
    resetTimer();
    render();
    log("Nuevo juego. T√∫ eres Negro. La IA es Blanco.");
    setStatus();
  }

  function restartGame(){
    // reinicia con el mismo nivel
    initBoard();
  }

  function log(msg){
    logEl.textContent = (logEl.textContent ? (logEl.textContent + "\n") : "") + msg;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function countPieces(b){
    let black=0, white=0;
    for(const v of b){
      if(v === BLACK) black++;
      else if(v === WHITE) white++;
    }
    return {black, white};
  }

  function cornersOwned(b){
    const corners = [0,7,56,63];
    let cb=0, cw=0;
    for(const i of corners){
      if(b[i] === BLACK) cb++;
      else if(b[i] === WHITE) cw++;
    }
    return {cb, cw};
  }

  // Movimientos legales: retorna lista de {pos, flips:[indices]}
  function legalMoves(b, player){
    const opp = -player;
    const moves = [];
    for(let i=0;i<64;i++){
      if(b[i] !== EMPTY) continue;
      const [r,c] = rc(i);
      let allFlips = [];
      for(const [dr,dc] of DIRS){
        let rr = r+dr, cc = c+dc;
        let line = [];
        while(inBounds(rr,cc) && b[idx(rr,cc)] === opp){
          line.push(idx(rr,cc));
          rr += dr; cc += dc;
        }
        if(line.length && inBounds(rr,cc) && b[idx(rr,cc)] === player){
          allFlips = allFlips.concat(line);
        }
      }
      if(allFlips.length){
        moves.push({pos:i, flips: allFlips});
      }
    }
    return moves;
  }

  function applyMove(b, move, player){
    const nb = cloneBoard(b);
    nb[move.pos] = player;
    for(const f of move.flips) nb[f] = player;
    return nb;
  }

  // Heur√≠stica (evaluaci√≥n): esquinas + movilidad + anti-X + diferencia de fichas ligera
  function evaluate(b){
    const {black, white} = countPieces(b);
    const diff = (black - white);

    const {cb, cw} = cornersOwned(b);
    const cornerScore = (cb - cw) * 50;

    // movilidad
    const mobB = legalMoves(b, BLACK).length;
    const mobW = legalMoves(b, WHITE).length;
    const mobility = (mobB - mobW) * 4;

    // penalizar "X" si esquina libre (X = diagonales a la esquina)
    const X = [idx(1,1), idx(1,6), idx(6,1), idx(6,6)];
    const corner = [idx(0,0), idx(0,7), idx(7,0), idx(7,7)];
    let xPenalty = 0;
    for(let k=0;k<4;k++){
      if(b[corner[k]] === EMPTY){
        if(b[X[k]] === BLACK) xPenalty -= 12;
        if(b[X[k]] === WHITE) xPenalty += 12;
      }
    }

    // fin de juego: diferencia importa much√≠simo
    const empties = b.filter(v => v===EMPTY).length;
    const endWeight = empties < 14 ? 6 : 1;
    const pieceScore = diff * endWeight;

    return cornerScore + mobility + xPenalty + pieceScore;
  }

  function isTerminal(b){
    // terminal si nadie puede jugar
    return legalMoves(b, BLACK).length === 0 && legalMoves(b, WHITE).length === 0;
  }

  function minimax(b, player, depth, alpha, beta){
    if(depth === 0 || isTerminal(b)){
      return {score: evaluate(b), best: null};
    }

    const moves = legalMoves(b, player);
    if(moves.length === 0){
      // pasar turno
      return minimax(b, -player, depth-1, alpha, beta);
    }

    let bestMove = null;

    if(player === BLACK){
      // max
      let bestScore = -Infinity;
      for(const m of moves){
        const nb = applyMove(b, m, player);
        const r = minimax(nb, -player, depth-1, alpha, beta);
        if(r.score > bestScore){
          bestScore = r.score;
          bestMove = m;
        }
        alpha = Math.max(alpha, bestScore);
        if(beta <= alpha) break;
      }
      return {score: bestScore, best: bestMove};
    }else{
      // min (IA blanca quiere minimizar evaluaci√≥n (que est√° desde negro))
      let bestScore = Infinity;
      for(const m of moves){
        const nb = applyMove(b, m, player);
        const r = minimax(nb, -player, depth-1, alpha, beta);
        if(r.score < bestScore){
          bestScore = r.score;
          bestMove = m;
        }
        beta = Math.min(beta, bestScore);
        if(beta <= alpha) break;
      }
      return {score: bestScore, best: bestMove};
    }
  }

  function aiDepth(){
    const lvl = levelSel.value;
    // profundidad moderada para que corra bien en m√≥vil
    // y sube un poquito al final del juego
    const empties = board.filter(v => v===EMPTY).length;
    const endBoost = empties < 16 ? 1 : 0;
    if(lvl === "low") return 2 + endBoost;
    if(lvl === "mid") return 3 + endBoost;
    return 4 + endBoost; // alto
  }

  function setStatus(){
    const {black, white} = countPieces(board);
    bCountEl.textContent = black;
    wCountEl.textContent = white;

    turnEl.textContent = (turn === BLACK) ? "Negro" : "Blanco";

    const lm = legalMoves(board, turn).length;
    if(isTerminal(board)){
      // fin
      stopTimer();
      const winner = black === white ? "Empate" : (black > white ? "Ganaste (Negro)" : "Perdiste (Blanco)");
      const {cb, cw} = cornersOwned(board);

      winBox.style.display = "block";
      winBox.style.borderColor = (black >= white) ? "rgba(57,217,138,.35)" : "rgba(255,92,122,.35)";
      winBox.style.background = (black >= white) ? "rgba(57,217,138,.10)" : "rgba(255,92,122,.10)";
      winBox.textContent = `Fin del juego: ${winner}. Esquinas ‚Äî Negro: ${cb}, Blanco: ${cw}.`;

      statusEl.textContent = "Juego terminado.";
      updateScore(true);
      return;
    }

    if(lm === 0){
      statusEl.textContent = `Sin jugadas para ${(turn===BLACK)?"Negro":"Blanco"} ‚Üí pasa turno.`;
    }else{
      statusEl.textContent = (turn===BLACK)
        ? "Tu turno (Negro). Juega por esquinas y movilidad."
        : "Turno de la IA (Blanco). Aguanta, que viene con intenciones.";
    }
    updateScore();
  }

  function updateScore(final=false){
    const {black, white} = countPieces(board);
    const {cb, cw} = cornersOwned(board);
    // Puntaje: diferencia + esquinas + penalizaci√≥n por tiempo y movimientos
    let s = (black - white) * 10 + (cb - cw) * 35 - Math.floor(seconds * 0.6) - moves * 2;
    if(final){
      if(black > white) s += 120;
      else if(black < white) s -= 60;
    }
    scoreEl.textContent = Math.max(0, s);
  }

  function clearHints(){
    hintIndex = null;
    [...boardEl.children].forEach(el => el.classList.remove("hint"));
  }

  function render(){
    boardEl.innerHTML = "";
    const valids = (turn === BLACK) ? legalMoves(board, BLACK) : []; // mostramos v√°lidas para el jugador
    const validSet = new Set(valids.map(m => m.pos));

    for(let i=0;i<64;i++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.setAttribute("data-i", i);

      if(validSet.has(i) && turn === BLACK){
        cell.classList.add("valid");
      }
      if(hintIndex === i){
        cell.classList.add("hint");
      }

      const v = board[i];
      if(v !== EMPTY){
        const d = document.createElement("div");
        d.className = "disc " + (v === BLACK ? "black" : "white");
        cell.appendChild(d);
      }

      cell.addEventListener("click", () => onCellClick(i));
      boardEl.appendChild(cell);
    }

    movesEl.textContent = moves;
    setStatus();
  }

  function pushHistory(){
    history.push({
      board: cloneBoard(board),
      turn,
      moves,
      seconds,
      started
    });
  }

  function popHistory(){
    const h = history.pop();
    if(!h) return false;
    board = cloneBoard(h.board);
    turn = h.turn;
    moves = h.moves;
    seconds = h.seconds;
    timeEl.textContent = formatTime(seconds);

    if(h.started){
      // reinicia timer sin duplicarlo
      if(timerId) clearInterval(timerId);
      started = false;
      startTimer();
    }else{
      resetTimer();
      seconds = h.seconds;
      timeEl.textContent = formatTime(seconds);
    }
    clearHints();
    render();
    return true;
  }

  function onCellClick(i){
    if(turn !== BLACK) return;
    const valids = legalMoves(board, BLACK);
    const move = valids.find(m => m.pos === i);
    if(!move) return;

    if(!started) startTimer();

    pushHistory();
    clearHints();

    board = applyMove(board, move, BLACK);
    moves++;

    log(`T√∫ (Negro) ‚Üí ${coord(i)}.`);
    turn = WHITE;
    render();

    // IA juega con peque√±o delay para que se sienta ‚Äúhumano‚Äù
    window.setTimeout(aiMove, 120);
  }

  function coord(i){
    const [r,c] = rc(i);
    const letter = "ABCDEFGH"[c];
    return `${letter}${r+1}`;
  }

  function passIfNeeded(player){
    const lm = legalMoves(board, player);
    if(lm.length === 0){
      log(`${player===BLACK?"Negro":"Blanco"} sin jugadas ‚Üí pasa.`);
      turn = -player;
      render();
      return true;
    }
    return false;
  }

  function aiMove(){
    if(isTerminal(board)) return;
    if(turn !== WHITE) return;

    // si IA no tiene jugadas, pasa
    if(passIfNeeded(WHITE)) {
      // si despu√©s del pase, jugador tampoco tiene, se termina en render()
      return;
    }

    const depth = aiDepth();
    const res = minimax(board, WHITE, depth, -Infinity, Infinity);
    const m = res.best;

    if(!m){
      // fallback: deber√≠a no pasar
      turn = BLACK;
      render();
      return;
    }

    pushHistory();
    board = applyMove(board, m, WHITE);
    moves++;
    log(`IA (Blanco) ‚Üí ${coord(m.pos)}.`);
    turn = BLACK;
    render();

    // si jugador no tiene jugadas, pasa autom√°tico
    if(passIfNeeded(BLACK)) {
      // luego intentamos que IA juegue si puede
      if(turn === WHITE) window.setTimeout(aiMove, 120);
    }
  }

  function hintForPlayer(){
    if(turn !== BLACK) return;
    const valids = legalMoves(board, BLACK);
    if(valids.length === 0){
      log("No tienes jugadas ahora mismo. Te toca pasar (autom√°tico).");
      passIfNeeded(BLACK);
      if(turn === WHITE) window.setTimeout(aiMove, 120);
      return;
    }

    const depth = Math.max(2, aiDepth()); // usa profundidad del nivel
    const res = minimax(board, BLACK, depth, -Infinity, Infinity);
    const best = res.best || valids[0];

    hintIndex = best.pos;
    render();
    log(`Sugerencia: prueba ${coord(best.pos)}.`);
    // resaltado temporal
    window.setTimeout(() => { hintIndex = null; render(); }, 900);
  }

  // Botones
  btnNew.addEventListener("click", () => initBoard());
  btnRestart.addEventListener("click", () => restartGame());
  btnUndo.addEventListener("click", () => {
    // Deshacer: vuelve 1 jugada (puede ser IA o tuya). Si quieres deshacer ‚Äúdoble‚Äù (tuya+IA), p√≠demelo y lo cambio.
    const ok = popHistory();
    if(!ok) log("Nada que deshacer.");
  });
  btnHint.addEventListener("click", () => hintForPlayer());
  levelSel.addEventListener("change", () => {
    log(`Nivel cambiado a: ${levelSel.options[levelSel.selectedIndex].text}.`);
  });

  // Inicio
  initBoard();
})();
</script>
</body>
</html>
