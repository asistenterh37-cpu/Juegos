<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bronx Planks Runner ‚Äî Por Soamy Lanza</title>
  <style>
    :root{
      --bg:#070a16; --panel:#0f1733; --panel2:#0b132b; --ink:#e9eefc;
      --muted:#b6c2ffcc; --line:#2b3566; --good:#06d6a0; --bad:#ff6b6b; --accent:#4cc9f0;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 700px at 50% -100px, #1b2a6b 0%, var(--bg) 55%);
      color:var(--ink);
    }
    .wrap{max-width:980px;margin:18px auto;padding:0 14px 18px;display:grid;gap:12px;justify-items:center}
    header{
      width:100%; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      padding:10px 12px; border:1px solid var(--line); border-radius:14px;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    header h1{margin:0;font-size:16px;font-weight:900;letter-spacing:.4px;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .chip{font-size:12px;padding:3px 8px;border-radius:999px;border:1px solid var(--line);color:var(--muted);background:#0c1431}
    .by{font-size:12px;color:var(--muted)}
    .stats{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;font-size:13px;color:var(--muted)}
    .stats b{color:var(--ink)}
    .board{
      width:100%;
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background:linear-gradient(180deg,#060a16,#050815);
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      position:relative;
    }
    canvas{display:block;width:100%;height:auto;aspect-ratio:16/10;background:#050815}
    .hudline{width:100%;display:flex;justify-content:space-between;gap:10px;color:var(--muted);font-size:12.5px;padding:0 2px;flex-wrap:wrap}
    .kbd{padding:2px 6px;border:1px solid var(--line);border-radius:8px;background:#0d1636;color:var(--ink);font-size:12px;margin:0 3px;white-space:nowrap}

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center; padding:16px;
      background:linear-gradient(180deg,rgba(5,8,21,.78),rgba(5,8,21,.92));
      backdrop-filter: blur(4px);
    }
    .card{
      width:min(820px,100%);
      border:1px solid var(--line);
      border-radius:18px;
      background:linear-gradient(180deg,rgba(15,23,51,.95),rgba(11,19,43,.92));
      box-shadow:0 20px 60px rgba(0,0,0,.45);
      padding:16px;
    }
    .card h2{margin:0 0 6px;font-size:18px}
    .card p{margin:6px 0;color:var(--muted);line-height:1.35}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    @media (max-width:760px){.grid{grid-template-columns:1fr}}
    .btn{
      appearance:none;border:1px solid var(--line);
      background:linear-gradient(180deg,#24306a,#18214a);
      color:var(--ink);border-radius:14px;padding:10px 12px;font-weight:900;cursor:pointer;
      display:flex;align-items:center;justify-content:center;gap:10px;user-select:none;
      box-shadow:0 10px 25px rgba(0,0,0,.25);
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:linear-gradient(180deg,#101a3f,#0c1431);color:var(--muted);font-weight:900}
    select, input[type="text"]{
      background:#070d22;color:var(--ink);border:1px solid var(--line);
      border-radius:12px;padding:10px 10px;font-weight:900;outline:none;
    }
    input[type="text"]{width:100%}
    .split{display:grid;grid-template-columns:1.2fr .8fr;gap:12px;margin-top:12px}
    @media (max-width:860px){.split{grid-template-columns:1fr}}
    .hsbox{
      border:1px solid var(--line);border-radius:16px;background:#0c1431;padding:12px
    }
    .hsbox h3{margin:0 0 8px;font-size:14px}
    .hslist{display:grid;gap:6px}
    .hsitem{
      display:flex;justify-content:space-between;gap:10px;padding:8px 10px;border:1px solid rgba(43,53,102,.65);
      border-radius:12px;background:rgba(7,13,34,.65);font-size:13px;color:var(--muted)
    }
    .hsitem b{color:var(--ink)}

    .touchbar{width:100%;display:none;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;margin-top:8px}
    .touchbtn{
      border:1px solid var(--line);border-radius:16px;
      background:linear-gradient(180deg,rgba(36,48,106,.85),rgba(24,33,74,.85));
      padding:14px 10px;font-weight:900;text-align:center;user-select:none;touch-action:manipulation;color:var(--ink)
    }
    .touchbtn:active{transform:translateY(1px)}
    .touchhint{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
    @media (pointer: coarse), (max-width: 820px){.touchbar{display:grid}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>BRONX PLANKS RUNNER <span class="chip">HTML5 Canvas</span> <span class="by">Por <b>Soamy Lanza</b></span></h1>
      <div class="stats">
        <div>Puntos: <b id="uiScore">0</b></div>
        <div>Monedas: <b id="uiCoins">0</b></div>
        <div>Combo: <b id="uiCombo">x1</b></div>
        <div>Doble salto: <b id="uiDJ">No</b></div>
        <div>Tiempo: <b id="uiTime">0.0</b>s</div>
        <div>Dificultad: <b id="uiDiff">Normal</b></div>
        <div>Best: <b id="uiBest">0</b></div>
      </div>
    </header>

    <div class="board">
      <canvas id="game" width="960" height="600"></canvas>

      <div class="overlay" id="overlay">
        <div class="card">
          <h2 id="ovTitle">üèÉ Bronx Planks Runner</h2>
          <p id="ovText">
            Salta planchas que se acercan. Agarra <b>monedas</b> üí∞ y el power-up de <b>doble salto</b> ‚≠ê.
            Ojo con planchas falsas y m√≥viles. (Firma: Por Soamy Lanza)
          </p>

          <div class="split">
            <div>
              <div class="row" style="margin-top:10px">
                <span class="chip">Nombre</span>
                <input id="playerName" type="text" maxlength="16" placeholder="Soamy" />
                <span class="chip">Dificultad</span>
                <select id="difficulty">
                  <option value="easy">Easy</option>
                  <option value="normal" selected>Normal</option>
                  <option value="hard">Hard</option>
                </select>
              </div>

              <div class="row" style="margin-top:10px">
                <span class="chip"><b>‚Üê ‚Üí</b> mover</span>
                <span class="chip"><b>‚Üë</b>/<b>Espacio</b> saltar</span>
                <span class="chip"><b>Shift</b> dash</span>
                <span class="chip"><b>P</b> pausa</span>
                <span class="chip"><b>R</b> reiniciar</span>
              </div>

              <div class="grid">
                <button class="btn" id="btnStart">‚ñ∂Ô∏è Jugar</button>
                <button class="btn secondary" id="btnHow">üéÆ C√≥mo se juega</button>
                <button class="btn secondary" id="btnResetHS">üßΩ Reset Ranking</button>
                <button class="btn secondary" id="btnResume" style="display:none;">‚è∏Ô∏è Reanudar</button>
              </div>

              <p id="howBox" style="display:none;margin-top:10px;color:var(--muted)">
                <b>Objetivo:</b> aguanta y suma puntos.<br>
                ‚úÖ Aterriza en planchas para subir combo.<br>
                üí∞ Monedas suman puntos extra.<br>
                ‚≠ê Power-up te da <b>doble salto</b> por unos segundos.<br>
                ‚ÜîÔ∏è Algunas planchas se mueven lateralmente.<br>
                ‚ùå Planchas ‚Äúfalsas‚Äù desaparecen antes de llegar.
              </p>
            </div>

            <div class="hsbox">
              <h3>üèÖ Ranking Top 10</h3>
              <div class="hslist" id="hsList"></div>
              <p style="margin:10px 0 0;color:var(--muted);font-size:12px">Guardado en tu navegador (LocalStorage).</p>
              <p style="margin:6px 0 0;color:var(--muted);font-size:12px">Por <b>Soamy Lanza</b></p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="hudline">
      <div>
        <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> mover ¬∑
        <span class="kbd">‚Üë</span>/<span class="kbd">Espacio</span> saltar ¬∑
        <span class="kbd">Shift</span> dash ¬∑
        <span class="kbd">P</span> pausa ¬∑
        <span class="kbd">R</span> reiniciar
      </div>
      <div id="uiMsg"></div>
    </div>

    <div class="touchbar" id="touchbar">
      <div class="touchbtn" data-act="left">‚¨ÖÔ∏è IZQ</div>
      <div class="touchbtn" data-act="right">‚û°Ô∏è DER</div>
      <div class="touchbtn" data-act="jump">‚¨ÜÔ∏è SALTAR</div>
      <div class="touchbtn" data-act="dash">‚ö° SHIFT</div>
    </div>
    <div class="touchhint">M√≥vil: mant√©n IZQ/DER presionado para moverte.</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // UI
  const uiScore = document.getElementById("uiScore");
  const uiCoins = document.getElementById("uiCoins");
  const uiCombo = document.getElementById("uiCombo");
  const uiDJ    = document.getElementById("uiDJ");
  const uiTime  = document.getElementById("uiTime");
  const uiDiff  = document.getElementById("uiDiff");
  const uiBest  = document.getElementById("uiBest");
  const uiMsg   = document.getElementById("uiMsg");

  // Menu
  const overlay = document.getElementById("overlay");
  const ovTitle = document.getElementById("ovTitle");
  const ovText  = document.getElementById("ovText");
  const btnStart = document.getElementById("btnStart");
  const btnHow = document.getElementById("btnHow");
  const btnResetHS = document.getElementById("btnResetHS");
  const btnResume = document.getElementById("btnResume");
  const howBox = document.getElementById("howBox");
  const difficultySel = document.getElementById("difficulty");
  const nameInput = document.getElementById("playerName");
  const hsList = document.getElementById("hsList");
  const touchbar = document.getElementById("touchbar");

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd = (a,b)=>a+Math.random()*(b-a);
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------- Ranking Top 10 ----------
  const HS_KEY = "bronx_planks_top10_v1";
  function loadHS(){
    try{
      const raw = localStorage.getItem(HS_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch{ return []; }
  }
  function saveHS(arr){
    localStorage.setItem(HS_KEY, JSON.stringify(arr.slice(0,10)));
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m]));
  }
  function renderHS(){
    const arr = loadHS();
    hsList.innerHTML = "";
    if (!arr.length){
      hsList.innerHTML = `<div class="hsitem"><span>‚Äî</span><span>Sin scores a√∫n</span></div>`;
      return;
    }
    arr.slice(0,10).forEach((it, i)=>{
      hsList.insertAdjacentHTML("beforeend",
        `<div class="hsitem">
          <span>#${i+1} <b>${escapeHtml((it.name||"Anon").slice(0,16))}</b></span>
          <span><b>${it.score}</b> ¬∑ ${it.diff} ¬∑ ${it.time}s</span>
        </div>`
      );
    });
  }
  function addHS(entry){
    const arr = loadHS();
    arr.push(entry);
    arr.sort((a,b)=> (b.score - a.score) || (b.time - a.time));
    saveHS(arr);
    renderHS();
  }

  // Best = top score from ranking
  function getBest(){
    const hs = loadHS();
    return hs[0]?.score ?? 0;
  }

  // ---------- Difficulty ----------
  const DIFF = {
    easy:   { label:"Easy",   speed: 320, spawn: 1.05, fakeRate: 0.16, mobileRate:0.18, coinRate:0.48, starRate:0.14, gapMin: 130, gapMax: 240, plankMin: 115, plankMax: 185, gravity: 1450, jumpV: 640, dashV: 620 },
    normal: { label:"Normal", speed: 420, spawn: 0.90, fakeRate: 0.24, mobileRate:0.26, coinRate:0.52, starRate:0.16, gapMin: 160, gapMax: 300, plankMin: 95,  plankMax: 160, gravity: 1600, jumpV: 680, dashV: 700 },
    hard:   { label:"Hard",   speed: 540, spawn: 0.76, fakeRate: 0.32, mobileRate:0.34, coinRate:0.56, starRate:0.20, gapMin: 190, gapMax: 340, plankMin: 80,  plankMax: 140, gravity: 1750, jumpV: 720, dashV: 780 },
  };

  // Game state
  const state = {
    running:false, paused:false, over:false,
    score:0, coins:0, combo:1, time:0,
    last:0,
    msgTimer:0,
    diffKey:"normal",
    playerName:"Soamy",
    stars:[],
    camShake:0,
    // double jump power
    djActive:false,
    djTimer:0,
  };

  // Stars
  function initStars(){
    state.stars = [];
    for (let i=0;i<95;i++){
      state.stars.push({ x:Math.random()*canvas.width, y:Math.random()*canvas.height, r:Math.random()*1.6+0.2, v:Math.random()*34+14 });
    }
  }
  initStars();

  // Lanes
  const laneY = {
    plank:  canvas.height - 240
  };

  // Player
  const player = {
    x: canvas.width/2,
    y: laneY.plank - 40,
    vx: 0,
    vy: 0,
    w: 26,
    h: 34,
    onPlank: true,
    canDouble: false,
    dash: 0,
    dashCooldown: 0,
  };

  // Planks (approach in z): each plank may have coin(s) and/or star power-up
  // plank: { x,yBase,width,z,vz,fake,fade,passed, mobile, mx, mdir, mrange, coin, star }
  let planks = [];
  let spawnTimer = 0;

  function showOverlay(){ overlay.style.display = "flex"; }
  function hideOverlay(){
    overlay.style.display = "none";
    howBox.style.display = "none";
    btnStart.style.display = "flex";
    btnResume.style.display = "none";
  }

  function showMsg(txt){
    uiMsg.textContent = txt;
    state.msgTimer = 2.2;
  }

  function updateUI(){
    uiScore.textContent = state.score;
    uiCoins.textContent = state.coins;
    uiCombo.textContent = "x" + state.combo;
    uiTime.textContent = state.time.toFixed(1);
    uiDiff.textContent = DIFF[state.diffKey].label;
    uiDJ.textContent = state.djActive ? "S√≠" : "No";
    uiBest.textContent = getBest();
  }

  function makePlank(x, yBase, width, z, speed, fake){
    return {
      x, yBase, width,
      z,
      vz: speed,
      fake,
      fade: 1,
      passed: false,

      mobile: false,
      mx: x,
      mdir: Math.random()<0.5 ? -1 : 1,
      mrange: rnd(40, 110),

      // collectible attachments (relative position on plank)
      coin: null, // { dx, taken }
      star: null, // { dx, taken }
    };
  }

  function resetGame(){
    state.over = false;
    state.running = true;
    state.paused = false;

    state.score = 0;
    state.coins = 0;
    state.combo = 1;
    state.time = 0;
    state.msgTimer = 0;
    state.camShake = 0;

    state.diffKey = difficultySel.value || "normal";
    state.playerName = (nameInput.value || "Soamy").trim().slice(0,16) || "Soamy";

    state.djActive = false;
    state.djTimer = 0;

    player.x = canvas.width/2;
    player.y = laneY.plank - 40;
    player.vx = 0;
    player.vy = 0;
    player.onPlank = true;
    player.canDouble = false;
    player.dash = 0;
    player.dashCooldown = 0;

    planks = [];
    spawnTimer = 0.25;

    const prof = DIFF[state.diffKey];

    // safe near plank
    const p0 = makePlank(canvas.width/2, laneY.plank, 150, 0.92, 0, false);
    planks.push(p0);

    // far planks
    for (let i=0;i<7;i++){
      const p = makePlank(
        rnd(220, canvas.width-220),
        laneY.plank,
        rnd(prof.plankMin, prof.plankMax),
        rnd(0.05, 0.45),
        prof.speed * rnd(0.92, 1.08),
        Math.random()<prof.fakeRate
      );
      attachStuffToPlank(p, prof);
      planks.push(p);
    }

    initStars();
    updateUI();
    hideOverlay();
    showMsg("¬°Vamos! Por Soamy Lanza");
  }

  function finishGame(){
    state.over = true;
    state.running = false;
    state.paused = false;

    const entry = {
      name: state.playerName,
      score: state.score,
      time: Number(state.time.toFixed(1)),
      diff: DIFF[state.diffKey].label,
      t: Date.now()
    };
    addHS(entry);

    ovTitle.textContent = "üí• Game Over";
    ovText.textContent = `Puntos: ${state.score} ¬∑ Monedas: ${state.coins} ¬∑ Tiempo: ${state.time.toFixed(1)}s ¬∑ Por Soamy Lanza`;
    btnStart.textContent = "üîÑ Reintentar";
    showOverlay();
    updateUI();

    if (state.score >= getBest()) showMsg("üèÜ ¬°Nuevo #1! (local)"); else showMsg("üí• Ca√≠ste. ¬°Otra!");
  }

  // Attach coins/powerups/moving behavior
  function attachStuffToPlank(p, prof){
    // moving plank?
    p.mobile = Math.random() < prof.mobileRate;
    if (p.mobile){
      p.mx = p.x;
      p.mrange = rnd(50, 140);
      p.mdir = Math.random()<0.5 ? -1 : 1;
    }

    // coin?
    if (Math.random() < prof.coinRate){
      p.coin = { dx: rnd(-0.25, 0.25), taken:false };
      // sometimes 2nd coin (rare)
      if (Math.random() < 0.12){
        p.coin2 = { dx: rnd(-0.35, 0.35), taken:false };
      } else {
        p.coin2 = null;
      }
    } else {
      p.coin = null;
      p.coin2 = null;
    }

    // double-jump star?
    if (Math.random() < prof.starRate){
      p.star = { dx: rnd(-0.2, 0.2), taken:false };
    } else {
      p.star = null;
    }
  }

  // Input
  const keys = new Set();
  const input = { left:false, right:false };

  function doJump(){
    if (!state.running || state.paused || state.over) return;
    const prof = DIFF[state.diffKey];

    if (player.onPlank){
      player.vy = -prof.jumpV;
      player.onPlank = false;
      player.canDouble = state.djActive; // allow 2nd jump if power active
      state.camShake = 0.04;
      return;
    }

    // double jump (if power active)
    if (state.djActive && player.canDouble){
      player.vy = -Math.round(prof.jumpV * 0.92);
      player.canDouble = false;
      showMsg("‚≠ê DOBLE SALTO!");
      state.camShake = 0.06;
    }
  }

  function doDash(){
    if (!state.running || state.paused || state.over) return;
    const prof = DIFF[state.diffKey];
    if (player.dashCooldown > 0) return;

    player.dash = 0.12;
    player.dashCooldown = 0.55;

    const dir = (input.right || keys.has("ArrowRight") ? 1 : 0) - (input.left || keys.has("ArrowLeft") ? 1 : 0);
    player.vx += (dir === 0 ? 1 : dir) * prof.dashV;
    showMsg("‚ö° DASH!");
  }

  window.addEventListener("keydown", (e)=>{
    if (e.code === "Space") e.preventDefault();
    keys.add(e.code);

    if (e.code === "ArrowUp" || e.code === "Space") doJump();
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") doDash();

    if (e.code === "KeyP"){
      if (!state.over){
        state.paused = !state.paused;
        if (state.paused){
          ovTitle.textContent = "‚è∏ Pausa";
          ovText.textContent = "Toca Reanudar o presiona P.";
          btnStart.style.display = "none";
          btnResume.style.display = "flex";
          showOverlay();
        } else {
          hideOverlay();
        }
      }
    }
    if (e.code === "KeyR"){
      resetGame();
    }
  });
  window.addEventListener("keyup", (e)=>keys.delete(e.code));

  // Touch controls
  function bindTouch(){
    const map = {
      left: (d)=> input.left = d,
      right:(d)=> input.right = d,
      jump:(d)=> { if (d) doJump(); },
      dash:(d)=> { if (d) doDash(); },
    };
    function press(el, fn){
      const on=(ev)=>{ ev.preventDefault(); fn(true); };
      const off=(ev)=>{ ev.preventDefault(); fn(false); };
      el.addEventListener("pointerdown", on);
      el.addEventListener("pointerup", off);
      el.addEventListener("pointercancel", off);
      el.addEventListener("pointerleave", off);
    }
    touchbar.querySelectorAll(".touchbtn").forEach(b=>{
      const act = b.getAttribute("data-act");
      if (map[act]) press(b, map[act]);
    });
  }
  bindTouch();

  // Menu buttons
  btnStart.addEventListener("click", ()=>{
    resetGame();
  });
  btnHow.addEventListener("click", ()=>{
    howBox.style.display = (howBox.style.display==="none") ? "block" : "none";
  });
  btnResetHS.addEventListener("click", ()=>{
    localStorage.removeItem(HS_KEY);
    renderHS();
    updateUI();
    showMsg("Ranking reseteado.");
  });
  btnResume.addEventListener("click", ()=>{
    if (!state.over){
      state.paused = false;
      hideOverlay();
    }
  });

  // ---------- Spawning ----------
  function spawnPlank(dt){
    spawnTimer -= dt;
    const prof = DIFF[state.diffKey];
    if (spawnTimer > 0) return;

    const tFactor = clamp(1 - state.time/95, 0.55, 1);
    spawnTimer = (prof.spawn * rnd(0.65, 1.20)) * tFactor;

    const width = rnd(prof.plankMin, prof.plankMax);

    const prevFar = planks
      .filter(p=>p.z < 0.35)
      .sort((a,b)=>a.z-b.z)[0];

    let x;
    if (prevFar){
      const step = rnd(prof.gapMin, prof.gapMax) * (Math.random()<0.5 ? -1 : 1);
      x = clamp(prevFar.x + step, 130, canvas.width - 130);
    } else {
      x = rnd(150, canvas.width - 150);
    }

    const fake = Math.random() < prof.fakeRate;
    const speed = prof.speed * rnd(0.92, 1.08);

    const p = makePlank(x, laneY.plank, width, rnd(0.03,0.16), speed, fake);
    attachStuffToPlank(p, prof);
    planks.push(p);
  }

  // ---------- Physics ----------
  function updatePlayer(dt){
    const prof = DIFF[state.diffKey];

    const left = input.left || keys.has("ArrowLeft");
    const right= input.right|| keys.has("ArrowRight");
    const dir = (right?1:0) - (left?1:0);

    const accel = 2300;
    const maxV = 540 + (player.dash>0 ? 540 : 0);
    player.vx += dir * accel * dt;

    // friction
    player.vx = lerp(player.vx, 0, clamp(12*dt, 0, 1));
    player.vx = clamp(player.vx, -maxV, maxV);
    player.x += player.vx * dt;
    player.x = clamp(player.x, 60, canvas.width - 60);

    player.dash = Math.max(0, player.dash - dt);
    player.dashCooldown = Math.max(0, player.dashCooldown - dt);

    // gravity
    player.vy += prof.gravity * dt;
    player.y += player.vy * dt;

    // landing
    let landed = false;

    for (const p of planks){
      if (p.fake && p.z > 0.75) continue;     // fake disappears before you
      if (p.z < 0.86 || p.z > 1.08) continue; // only near collision zone

      // perspective scale
      const scale = 0.35 + p.z * 0.85;
      const w = p.width * scale;
      const plankY = p.yBase + (1 - p.z) * 240;
      const plankH = 18 * scale;

      const leftX = p.x - w/2;
      const rightX = p.x + w/2;

      const feetY = player.y + player.h/2;

      if (player.vy > 0 && feetY >= plankY - plankH/2 && feetY <= plankY + plankH/2){
        if (player.x >= leftX && player.x <= rightX){
          player.y = plankY - player.h/2;
          player.vy = 0;
          player.onPlank = true;
          landed = true;

          // reset double-jump availability while grounded
          player.canDouble = state.djActive;

          if (!p.passed){
            p.passed = true;
            const add = 12 * state.combo;
            state.score += add;
            state.combo = Math.min(9, state.combo + 1);
            showMsg(`‚úÖ +${add} (x${state.combo})`);
          }

          // collectibles check when landing (and also while standing)
          tryCollectOnPlank(p, scale, w, plankY);
        }
      } else {
        // if player overlaps while standing, allow collecting too
        if (player.onPlank && Math.abs((player.y + player.h/2) - plankY) < 2 && player.x >= leftX && player.x <= rightX){
          tryCollectOnPlank(p, scale, w, plankY);
        }
      }
    }

    if (!landed && player.onPlank){
      player.onPlank = false;
    }

    // fall => game over
    if (player.y > canvas.height + 140){
      finishGame();
    }
  }

  function tryCollectOnPlank(p, scale, w, plankY){
    // coin positions are relative dx in [-0.5..0.5] of plank width
    const px = player.x;

    // Coin 1
    if (p.coin && !p.coin.taken){
      const cx = p.x + p.coin.dx * w;
      const cy = plankY - 26 * scale;
      if (dist(px, player.y, cx, cy) < 30){
        p.coin.taken = true;
        state.coins += 1;
        const add = 40 + state.combo*6;
        state.score += add;
        showMsg(`üí∞ +${add}`);
      }
    }
    // Coin 2
    if (p.coin2 && !p.coin2.taken){
      const cx = p.x + p.coin2.dx * w;
      const cy = plankY - 26 * scale;
      if (dist(px, player.y, cx, cy) < 30){
        p.coin2.taken = true;
        state.coins += 1;
        const add = 40 + state.combo*6;
        state.score += add;
        showMsg(`üí∞ +${add}`);
      }
    }
    // Star power-up
    if (p.star && !p.star.taken){
      const sx = p.x + p.star.dx * w;
      const sy = plankY - 30 * scale;
      if (dist(px, player.y, sx, sy) < 32){
        p.star.taken = true;
        state.djActive = true;
        state.djTimer = 10.0; // seconds
        player.canDouble = true;
        showMsg("‚≠ê DOBLE SALTO (10s)");
      }
    }
  }

  function dist(ax, ay, bx, by){
    const dx = ax - bx, dy = ay - by;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function updatePlanks(dt){
    const prof = DIFF[state.diffKey];

    for (const p of planks){
      // approach
      const zSpeed = (p.vz / 1000);
      p.z += zSpeed * dt;

      // fake fade out mid-way
      if (p.fake && p.z > 0.55){
        p.fade -= dt * 1.35;
      }
      // after passing player, fade away
      if (p.z > 1.18){
        p.fade -= dt * 1.25;
      }

      // moving plank lateral movement (stronger when near)
      if (p.mobile && !p.fake){
        const nearFactor = clamp(p.z, 0.1, 1.0);
        p.mx += p.mdir * dt * (65 + nearFactor*85);
        if (p.mx > p.x + p.mrange){ p.mx = p.x + p.mrange; p.mdir *= -1; }
        if (p.mx < p.x - p.mrange){ p.mx = p.x - p.mrange; p.mdir *= -1; }
        // blend x towards mx
        p.x = lerp(p.x, p.mx, clamp(dt*4.0, 0, 1));
      }

      // clamp bounds
      p.x = clamp(p.x, 110, canvas.width - 110);
    }

    planks = planks.filter(p => p.fade > 0.02);
  }

  function updateStars(dt){
    for (const s of state.stars){
      s.y += s.v * dt;
      if (s.y > canvas.height+10){
        s.y = -10;
        s.x = Math.random()*canvas.width;
        s.v = rnd(18,56);
        s.r = rnd(0.4,2.0);
      }
    }
  }

  function update(dt){
    updateStars(dt);
    if (!state.running || state.paused || state.over) return;

    state.time += dt;

    if (state.msgTimer > 0){
      state.msgTimer -= dt;
      if (state.msgTimer <= 0) uiMsg.textContent = "";
    }

    // double jump timer
    if (state.djActive){
      state.djTimer -= dt;
      if (state.djTimer <= 0){
        state.djActive = false;
        state.djTimer = 0;
        player.canDouble = false;
        showMsg("‚≠ê Doble salto termin√≥");
      }
    }

    spawnPlank(dt);
    updatePlanks(dt);
    updatePlayer(dt);

    // combo decay if too long airborne
    if (!player.onPlank && state.combo > 1){
      // gentle decay
      state.combo = Math.max(1, state.combo - dt*0.35);
      // keep integer in UI by rounding up
    }

    // force combo to int-ish for UI & scoring
    state.combo = clamp(Math.round(state.combo), 1, 9);

    updateUI();
  }

  // ---------- Drawing ----------
  function drawCoin(x, y, r, a=1){
    ctx.save();
    ctx.globalAlpha = a;
    // coin glow
    ctx.fillStyle = "rgba(255,209,102,0.20)";
    ctx.beginPath(); ctx.arc(x, y, r*1.8, 0, Math.PI*2); ctx.fill();
    // coin body
    ctx.fillStyle = "rgba(255,209,102,0.95)";
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    // inner shine
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.beginPath(); ctx.arc(x - r*0.25, y - r*0.25, r*0.35, 0, Math.PI*2); ctx.fill();
    // edge
    ctx.strokeStyle = "rgba(255,209,102,1)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function drawStar(x, y, s, a=1){
    ctx.save();
    ctx.globalAlpha = a;
    ctx.fillStyle = "rgba(76,201,240,0.22)";
    ctx.beginPath(); ctx.arc(x, y, s*1.9, 0, Math.PI*2); ctx.fill();

    ctx.translate(x, y);
    ctx.fillStyle = "rgba(76,201,240,0.95)";
    ctx.beginPath();
    for (let i=0;i<10;i++){
      const ang = (i*Math.PI)/5;
      const rad = (i%2===0) ? s : s*0.45;
      ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawPlank(p){
    const scale = 0.35 + p.z * 0.85;
    const w = p.width * scale;
    const plankY = p.yBase + (1 - p.z) * 240;
    const h = 18 * scale;
    const alpha = clamp(p.fade, 0, 1);

    const base = p.fake ? `rgba(255,107,107,${0.55*alpha})` : `rgba(76,201,240,${0.60*alpha})`;
    const edge = p.fake ? `rgba(255,107,107,${0.95*alpha})` : `rgba(76,201,240,${0.95*alpha})`;

    // shadow
    ctx.globalAlpha = 0.35*alpha;
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(p.x - w/2 + 6, plankY - h/2 + 8, w, h);
    ctx.globalAlpha = 1;

    // plank
    ctx.fillStyle = base;
    ctx.fillRect(p.x - w/2, plankY - h/2, w, h);
    ctx.strokeStyle = edge;
    ctx.lineWidth = 2;
    ctx.strokeRect(p.x - w/2, plankY - h/2, w, h);

    // moving indicator
    if (p.mobile && !p.fake){
      ctx.globalAlpha = 0.55*alpha;
      ctx.fillStyle = "rgba(255,255,255,0.35)";
      ctx.fillRect(p.x - w/2, plankY - h/2 - 6, w, 3);
      ctx.globalAlpha = 1;
    }

    // collectibles on plank
    const r = 8 * scale;
    const cy = plankY - 26 * scale;

    if (p.coin && !p.coin.taken){
      const cx = p.x + p.coin.dx * w;
      drawCoin(cx, cy, r, alpha);
    }
    if (p.coin2 && !p.coin2.taken){
      const cx = p.x + p.coin2.dx * w;
      drawCoin(cx, cy, r, alpha);
    }
    if (p.star && !p.star.taken){
      const sx = p.x + p.star.dx * w;
      drawStar(sx, plankY - 30*scale, 10*scale, alpha);
    }
  }

  function drawPlayer(){
    const x = player.x, y = player.y;
    // body
    ctx.fillStyle = "rgba(183,255,218,0.95)";
    ctx.fillRect(x-10, y-18, 20, 22);
    // head
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.fillRect(x-7, y-32, 14, 14);
    // cap
    ctx.fillStyle = "rgba(255,107,107,0.95)";
    ctx.fillRect(x-7, y-36, 14, 6);
    // feet
    ctx.fillStyle = "rgba(255,209,102,0.95)";
    ctx.fillRect(x-10, y+4, 8, 6);
    ctx.fillRect(x+2, y+4, 8, 6);

    // dash trail
    if (player.dash > 0){
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(76,201,240,0.95)";
      ctx.fillRect(x-22, y-10, 10, 10);
      ctx.fillRect(x-34, y-6, 8, 8);
      ctx.globalAlpha = 1;
    }

    // double jump aura
    if (state.djActive){
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(76,201,240,0.9)";
      ctx.beginPath(); ctx.arc(x, y-10, 28, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;

      ctx.fillStyle = "rgba(76,201,240,0.9)";
      ctx.font = "12px system-ui, Arial";
      ctx.fillText(`‚≠ê ${state.djTimer.toFixed(0)}s`, x-18, y-44);
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // bg glow
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,"rgba(76,201,240,0.15)");
    g.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // stars
    ctx.fillStyle = "#fff";
    for (const s of state.stars){
      ctx.globalAlpha = clamp(s.r/2.3, 0.2, 0.9);
      ctx.fillRect(s.x, s.y, s.r, s.r);
    }
    ctx.globalAlpha = 1;

    // horizon
    ctx.strokeStyle = "rgba(43,53,102,0.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, laneY.plank - 220);
    ctx.lineTo(canvas.width, laneY.plank - 220);
    ctx.stroke();

    // planks far -> near
    const sorted = [...planks].sort((a,b)=>a.z-b.z);
    for (const p of sorted) drawPlank(p);

    // player
    drawPlayer();

    // signature
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "14px system-ui, Arial";
    ctx.fillText("Por Soamy Lanza", 14, canvas.height - 18);
    ctx.globalAlpha = 1;
  }

  // Main loop
  function loop(t){
    const time = t/1000;
    const dt = Math.min(0.033, time - (state.last||time));
    state.last = time;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Init
  nameInput.value = "Soamy";
  renderHS();
  updateUI();
  showOverlay();
})();
</script>
</body>
</html>
