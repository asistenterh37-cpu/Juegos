<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rompecabezas 3-en-1 (Deslizante ‚Ä¢ Cubos ‚Ä¢ Laberinto)</title>
  <style>
    :root{
      --bg:#0b1020; --card:#111a33; --card2:#0f1630; --txt:#e9efff; --muted:#9fb0ff;
      --acc:#6ae4ff; --acc2:#9b7dff; --danger:#ff5e7a; --ok:#49f7a1;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --r:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1000px 700px at 30% 0%, rgba(106,228,255,.20), transparent 60%),
                  radial-gradient(900px 650px at 90% 20%, rgba(155,125,255,.18), transparent 60%),
                  var(--bg);
      color:var(--txt);
      min-height:100vh;
      padding: clamp(10px, 2.2vw, 18px);
    }

    .app{
      max-width: 1100px;
      margin: 0 auto;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
    }

    @media (max-width: 940px){
      .app{grid-template-columns: 1fr; }
    }

    .panel, .stage{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panel header{
      padding:14px 14px 10px;
      background: linear-gradient(90deg, rgba(106,228,255,.10), rgba(155,125,255,.08));
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .title{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .title h1{font-size:16px; margin:0; letter-spacing:.2px}
    .badge{
      font-size:12px; color:var(--muted);
      border:1px solid rgba(255,255,255,.14);
      padding:4px 8px; border-radius:999px;
      background: rgba(15,22,48,.45);
    }

    .panel .content{ padding: 12px 14px 14px; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; }
    .field{ flex:1; min-width: 150px; }
    label{ font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    select, button{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,22,48,.55);
      color: var(--txt);
      outline:none;
      font-size:14px;
    }
    select:focus, button:focus{ box-shadow: 0 0 0 3px rgba(106,228,255,.22); }
    button{
      cursor:pointer;
      transition: transform .06s ease, filter .15s ease;
      user-select:none;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    .btns{ margin-top: 10px; display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
    .btn-wide{ grid-column: 1 / -1; }

    .primary{ border-color: rgba(106,228,255,.35); background: rgba(106,228,255,.10); }
    .danger{ border-color: rgba(255,94,122,.35); background: rgba(255,94,122,.10); }
    .ghost{ background: rgba(15,22,48,.35); }

    .stats{
      margin-top: 12px;
      display:grid; grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .stat{
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,22,48,.40);
    }
    .stat .k{ font-size:11px; color:var(--muted); }
    .stat .v{ font-size:16px; margin-top:4px; font-variant-numeric: tabular-nums; }

    .hint{
      margin-top: 10px;
      padding:10px 12px;
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,.16);
      color: rgba(233,239,255,.88);
      background: rgba(17,26,51,.45);
      font-size: 13px;
      line-height: 1.35;
    }

    /* Stage */
    .stage header{
      padding:12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      background: rgba(15,22,48,.35);
    }
    .stage header .subtitle{ font-size:12px; color:var(--muted); }
    .stage header .status{
      font-size:13px;
      color: rgba(233,239,255,.92);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(15,22,48,.55);
      padding:6px 10px;
      border-radius: 999px;
      max-width: 55%;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .play{
      padding: 14px;
      display:grid;
      place-items:center;
      min-height: 520px;
    }
    @media (max-width: 940px){ .play{ min-height: 420px; } }

    /* Sliding puzzle */
    .grid{
      width: min(520px, 92vw);
      aspect-ratio: 1/1;
      display:grid;
      gap:8px;
      padding:10px;
      border-radius: 18px;
      background: rgba(15,22,48,.35);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      touch-action: manipulation;
    }
    .tile{
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(106,228,255,.20), rgba(155,125,255,.16));
      border: 1px solid rgba(255,255,255,.16);
      display:grid;
      place-items:center;
      font-size: clamp(18px, 3.4vw, 28px);
      font-weight: 700;
      user-select:none;
      cursor:pointer;
      position:relative;
      overflow:hidden;
    }
    .tile:before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(220px 180px at 30% 20%, rgba(255,255,255,.18), transparent 60%);
      pointer-events:none;
    }
    .tile.blank{
      background: rgba(15,22,48,.20);
      border: 1px dashed rgba(255,255,255,.16);
      cursor: default;
    }
    .tile.blank:before{ display:none; }
    .tile.good{ outline: 2px solid rgba(73,247,161,.35); }

    /* Cubes (Lights Out style) */
    .cubeWrap{
      width:min(520px, 92vw);
      aspect-ratio:1/1;
      display:grid;
      gap:8px;
      padding:10px;
      border-radius: 18px;
      background: rgba(15,22,48,.35);
      border: 1px solid rgba(255,255,255,.10);
      touch-action: manipulation;
    }
    .cube{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(15,22,48,.40);
      position:relative;
      cursor:pointer;
      overflow:hidden;
      transform: translateZ(0);
    }
    .cube.on{
      background: linear-gradient(180deg, rgba(73,247,161,.22), rgba(106,228,255,.12));
      border-color: rgba(73,247,161,.30);
    }
    .cube:before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(135deg, rgba(255,255,255,.20), transparent 55%),
        radial-gradient(180px 140px at 30% 20%, rgba(255,255,255,.16), transparent 62%);
      opacity:.55;
      pointer-events:none;
    }

    /* Maze */
    canvas{
      width:min(640px, 94vw);
      height:auto;
      aspect-ratio: 1/1;
      border-radius: 18px;
      background: rgba(15,22,48,.35);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      touch-action: none;
    }

    .touchPad{
      margin-top:12px;
      width:min(320px, 88vw);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      user-select:none;
    }
    .touchPad button{ padding:14px 10px; border-radius: 16px; }
    .touchPad .mid{ visibility:hidden; }
  </style>
</head>
<body>
  <div class="app">
    <section class="panel" aria-label="Controles">
      <header>
        <div class="title">
          <h1>Rompecabezas 3-en-1</h1>
          <span class="badge">Listo para WhatsApp/Facebook</span>
        </div>
      </header>
      <div class="content">
        <div class="row">
          <div class="field">
            <label for="mode">Modo</label>
            <select id="mode">
              <option value="slide">Deslizante</option>
              <option value="cubes">Cubos</option>
              <option value="maze">Laberinto</option>
            </select>
          </div>
          <div class="field">
            <label for="level">Nivel</label>
            <select id="level">
              <option value="low">Bajo</option>
              <option value="mid">Medio</option>
              <option value="high">Alto</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button class="primary" id="btnNew">Nuevo</button>
          <button class="ghost" id="btnRestart">Reiniciar</button>
          <button class="danger" id="btnClear">Limpiar</button>
          <button class="primary" id="btnSolve">Resolver</button>
          <button class="ghost btn-wide" id="btnPause">Pausar ‚è∏</button>
        </div>

        <div class="stats">
          <div class="stat">
            <div class="k">Cron√≥metro</div>
            <div class="v" id="time">00:00</div>
          </div>
          <div class="stat">
            <div class="k">Movimientos</div>
            <div class="v" id="moves">0</div>
          </div>
          <div class="stat">
            <div class="k">Estado</div>
            <div class="v" id="result">‚Äî</div>
          </div>
        </div>

        <div class="hint" id="hint">
          <b>Tips r√°pidos:</b> <br/>
          ‚Ä¢ Deslizante: toca una ficha al lado del hueco. <br/>
          ‚Ä¢ Cubos: toca para encender/apagar (tipo ‚ÄúLights Out‚Äù). <br/>
          ‚Ä¢ Laberinto: flechas del teclado o botones en pantalla.
        </div>
      </div>
    </section>

    <section class="stage" aria-label="Juego">
      <header>
        <div>
          <div id="stageTitle" style="font-weight:700;">Deslizante</div>
          <div class="subtitle" id="stageSub">Nivel Bajo</div>
        </div>
        <div class="status" id="status">Crea un juego con ‚ÄúNuevo‚Äù.</div>
      </header>

      <div class="play" id="playArea"></div>
    </section>
  </div>

<script>
(() => {
  // ---------- Helpers ----------
  const $ = (id) => document.getElementById(id);
  const playArea = $("playArea");

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function fmtTime(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec/60), s = sec%60;
    return String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
  }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  // ---------- Global state ----------
  const ui = {
    mode: $("mode"),
    level: $("level"),
    btnNew: $("btnNew"),
    btnRestart: $("btnRestart"),
    btnClear: $("btnClear"),
    btnSolve: $("btnSolve"),
    btnPause: $("btnPause"),
    time: $("time"),
    moves: $("moves"),
    result: $("result"),
    status: $("status"),
    stageTitle: $("stageTitle"),
    stageSub: $("stageSub"),
    hint: $("hint"),
  };

  const state = {
    mode: "slide",
    level: "low",
    paused: false,
    startedAt: 0,
    elapsed: 0,
    timerId: null,
    moves: 0,
    solved: false,

    // per-mode snapshots for restart
    snapshot: null,

    // slide
    slide: { n: 3, board: [], blank: 0 },

    // cubes (Lights Out)
    cubes: { n: 5, cells: [] },

    // maze
    maze: { n: 15, grid: null, start: [0,0], end:[0,0], player:[0,0], path: null, canvas:null, ctx:null, cellSize: 0 },
  };

  function setStatus(msg){ ui.status.textContent = msg; }
  function setResult(msg){ ui.result.textContent = msg; }
  function resetCounters(){
    state.moves = 0; state.solved = false;
    ui.moves.textContent = "0";
    setResult("‚Äî");
  }

  // ---------- Timer ----------
  function stopTimer(){
    if(state.timerId){ clearInterval(state.timerId); state.timerId=null; }
  }
  function startTimer(){
    stopTimer();
    state.startedAt = Date.now();
    state.timerId = setInterval(() => {
      if(state.paused) return;
      const now = Date.now();
      ui.time.textContent = fmtTime(state.elapsed + (now - state.startedAt)/1000);
    }, 200);
  }
  function resetTimer(){
    state.elapsed = 0;
    ui.time.textContent = "00:00";
    state.startedAt = Date.now();
  }
  function pauseToggle(){
    state.paused = !state.paused;
    ui.btnPause.textContent = state.paused ? "Reanudar ‚ñ∂" : "Pausar ‚è∏";
    if(!state.paused){
      // adjust start time so elapsed continues nicely
      state.startedAt = Date.now();
    }else{
      // bake elapsed up to now
      state.elapsed += (Date.now()-state.startedAt)/1000;
    }
  }

  function incMove(){
    state.moves++;
    ui.moves.textContent = String(state.moves);
  }

  function markSolved(extra=""){
    state.solved = true;
    // bake elapsed
    state.elapsed += (Date.now()-state.startedAt)/1000;
    state.startedAt = Date.now();
    setResult("‚úÖ Hecho");
    setStatus("¬°Resuelto! " + extra);
  }

  // ---------- Difficulty presets ----------
  function preset(mode, level){
    if(mode==="slide"){
      return level==="low" ? 3 : level==="mid" ? 4 : 5;
    }
    if(mode==="cubes"){
      return level==="low" ? 4 : level==="mid" ? 5 : 6; // keep solver quick
    }
    if(mode==="maze"){
      return level==="low" ? 15 : level==="mid" ? 23 : 31;
    }
    return 3;
  }

  // =========================================================
  //                     SLIDING PUZZLE
  // =========================================================
  function slideSolved(board){
    const n = state.slide.n;
    for(let i=0;i<n*n-1;i++){
      if(board[i] !== i+1) return false;
    }
    return board[n*n-1] === 0;
  }

  function slideInversions(arr){
    const a = arr.filter(x=>x!==0);
    let inv=0;
    for(let i=0;i<a.length;i++){
      for(let j=i+1;j<a.length;j++){
        if(a[i] > a[j]) inv++;
      }
    }
    return inv;
  }

  function slideSolvable(board, n){
    const inv = slideInversions(board);
    const blankIndex = board.indexOf(0);
    const blankRowFromBottom = n - Math.floor(blankIndex / n);
    if(n%2===1){
      return inv%2===0;
    }else{
      // even grid: solvable if (blank on even row from bottom) XOR (inv even)
      const blankEven = blankRowFromBottom % 2 === 0;
      const invEven = inv % 2 === 0;
      return blankEven !== invEven;
    }
  }

  function slideGenerate(n){
    const board = Array.from({length:n*n}, (_,i)=> i===n*n-1 ? 0 : i+1);
    let candidate = board.slice();
    do{
      candidate = board.slice();
      shuffle(candidate);
    }while(!slideSolvable(candidate, n) || slideSolved(candidate));
    return candidate;
  }

  function slideRender(){
    playArea.innerHTML = "";
    const n = state.slide.n;
    const grid = document.createElement("div");
    grid.className = "grid";
    grid.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${n}, 1fr)`;

    state.slide.board.forEach((val, idx) => {
      const t = document.createElement("div");
      t.className = "tile" + (val===0 ? " blank" : "");
      if(val!==0) t.textContent = val;

      // optional "correct placement" outline (small dopamine, big HR vibes)
      if(val!==0 && val===idx+1) t.classList.add("good");

      t.addEventListener("click", () => {
        if(state.paused || state.solved) return;
        if(val===0) return;
        const bi = state.slide.board.indexOf(0);
        const r = Math.floor(idx/n), c = idx%n;
        const br = Math.floor(bi/n), bc = bi%n;
        const man = Math.abs(r-br)+Math.abs(c-bc);
        if(man===1){
          state.slide.board[bi] = val;
          state.slide.board[idx] = 0;
          incMove();
          slideRender();
          if(slideSolved(state.slide.board)){
            markSolved(`Movs: ${state.moves}`);
          }else{
            setStatus("Sigue‚Ä¶ el huequito no se va a mover solo üòÑ");
          }
        }
      });

      grid.appendChild(t);
    });

    playArea.appendChild(grid);
  }

  // Simple solve via A* for 3x3 only (low). For 4x4/5x5 uses "show goal" instant.
  function slideSerialize(b){ return b.join(","); }
  function slideNeighbors(board, n){
    const bi = board.indexOf(0);
    const r = Math.floor(bi/n), c = bi%n;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const res=[];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr<0||nc<0||nr>=n||nc>=n) continue;
      const ni = nr*n+nc;
      const nb = board.slice();
      nb[bi] = nb[ni];
      nb[ni] = 0;
      res.push(nb);
    }
    return res;
  }
  function slideHeuristic(board, n){
    // manhattan distance
    let d=0;
    for(let i=0;i<board.length;i++){
      const v = board[i];
      if(v===0) continue;
      const tr = Math.floor((v-1)/n), tc = (v-1)%n;
      const r = Math.floor(i/n), c=i%n;
      d += Math.abs(r-tr)+Math.abs(c-tc);
    }
    return d;
  }
  async function slideSolveAnimate(){
    const n = state.slide.n;
    if(n!==3){
      // keep it safe & fast: for larger boards, just reset to solved.
      state.slide.board = Array.from({length:n*n}, (_,i)=> i===n*n-1?0:i+1);
      slideRender();
      markSolved("Resuelto (modo r√°pido).");
      return;
    }

    const start = state.slide.board.slice();
    const goal = Array.from({length:9}, (_,i)=> i===8?0:i+1);
    const goalKey = slideSerialize(goal);
    const startKey = slideSerialize(start);

    // A* (tiny board => OK)
    const open = new Map(); // key -> {b,g,f,prev}
    const pq = []; // simple array priority queue
    function push(node){
      pq.push(node);
      pq.sort((a,b)=>a.f-b.f);
    }

    open.set(startKey, {b:start, g:0, f:slideHeuristic(start,3), prev:null});
    push({key:startKey, f:slideHeuristic(start,3)});

    const seen = new Set();
    let foundKey = null;
    const maxIter = 35000;

    for(let iter=0; iter<maxIter && pq.length; iter++){
      const cur = pq.shift();
      if(seen.has(cur.key)) continue;
      seen.add(cur.key);
      if(cur.key===goalKey){ foundKey = cur.key; break; }
      const curNode = open.get(cur.key);
      const neigh = slideNeighbors(curNode.b,3);
      for(const nb of neigh){
        const k = slideSerialize(nb);
        if(seen.has(k)) continue;
        const ng = curNode.g + 1;
        const old = open.get(k);
        if(!old || ng < old.g){
          const nf = ng + slideHeuristic(nb,3);
          open.set(k, {b:nb, g:ng, f:nf, prev:cur.key});
          push({key:k, f:nf});
        }
      }
    }

    if(!foundKey){
      setStatus("No pude resolver (raro). Intenta Nuevo.");
      return;
    }

    // reconstruct
    const path = [];
    let k = foundKey;
    while(k){
      path.push(open.get(k).b);
      k = open.get(k).prev;
    }
    path.reverse();

    setStatus("Resolviendo‚Ä¶");
    for(let i=0;i<path.length;i++){
      if(state.paused) { i--; await new Promise(r=>setTimeout(r,150)); continue; }
      state.slide.board = path[i].slice();
      slideRender();
      await new Promise(r=>setTimeout(r, 110));
    }
    markSolved(`Movs: ${state.moves} (tu contador)`);
  }

  // =========================================================
  //                  CUBES (LIGHTS OUT)
  // =========================================================
  function cubesSolved(cells){
    return cells.every(v => v===0);
  }

  function cubesIdx(r,c,n){ return r*n + c; }
  function cubesToggle(cells, r,c,n){
    const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr<0||nc<0||nr>=n||nc>=n) continue;
      const i = cubesIdx(nr,nc,n);
      cells[i] ^= 1;
    }
  }

  function cubesGenerate(n){
    // Start from solved and apply random presses => always solvable
    const cells = Array(n*n).fill(0);
    const presses = Math.floor(n*n*0.65);
    for(let k=0;k<presses;k++){
      const r = Math.floor(Math.random()*n);
      const c = Math.floor(Math.random()*n);
      cubesToggle(cells, r,c,n);
    }
    if(cubesSolved(cells)) cubesToggle(cells, 0,0,n);
    return cells;
  }

  function cubesRender(){
    playArea.innerHTML = "";
    const n = state.cubes.n;
    const wrap = document.createElement("div");
    wrap.className="cubeWrap";
    wrap.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
    wrap.style.gridTemplateRows = `repeat(${n}, 1fr)`;

    state.cubes.cells.forEach((v, i) => {
      const r = Math.floor(i/n), c=i%n;
      const d = document.createElement("div");
      d.className = "cube" + (v? " on":"");
      d.title = "Toca para alternar";
      d.addEventListener("click", () => {
        if(state.paused || state.solved) return;
        cubesToggle(state.cubes.cells, r,c,n);
        incMove();
        cubesRender();
        if(cubesSolved(state.cubes.cells)){
          markSolved(`Movs: ${state.moves}`);
        }else{
          setStatus("Tip: apagar es m√°s barato que terapia (a veces).");
        }
      });
      wrap.appendChild(d);
    });

    playArea.appendChild(wrap);
  }

  // Solve Lights Out with linear algebra mod 2
  function cubesSolveExact(){
    const n = state.cubes.n;
    const N = n*n;
    const A = Array.from({length:N}, () => Array(N).fill(0));
    const b = state.cubes.cells.slice(); // want to reach all zero, so A*x = b

    function pressAffects(i, j){
      // if pressing j toggles i?
      const ir = Math.floor(i/n), ic=i%n;
      const jr = Math.floor(j/n), jc=j%n;
      const man = Math.abs(ir-jr)+Math.abs(ic-jc);
      return (man===0 || man===1) ? 1 : 0;
    }

    for(let i=0;i<N;i++){
      for(let j=0;j<N;j++){
        A[i][j] = pressAffects(i,j);
      }
    }

    // Gaussian elimination over GF(2)
    let row=0;
    const colToRow = Array(N).fill(-1);

    for(let col=0; col<N && row<N; col++){
      let pivot = -1;
      for(let r=row; r<N; r++){
        if(A[r][col]===1){ pivot=r; break; }
      }
      if(pivot===-1) continue;

      // swap
      [A[row], A[pivot]] = [A[pivot], A[row]];
      [b[row], b[pivot]] = [b[pivot], b[row]];
      colToRow[col]=row;

      // eliminate
      for(let r=0; r<N; r++){
        if(r!==row && A[r][col]===1){
          for(let c=col; c<N; c++) A[r][c] ^= A[row][c];
          b[r] ^= b[row];
        }
      }
      row++;
    }

    // check inconsistency
    for(let r=row; r<N; r++){
      const all0 = A[r].every(v=>v===0);
      if(all0 && b[r]===1){
        return null; // no solution (shouldn't happen here)
      }
    }

    // back-substitute: since we reduced fully, we can read x from pivot rows
    const x = Array(N).fill(0);
    for(let col=0; col<N; col++){
      const r = colToRow[col];
      if(r!==-1){
        // A[r][col]=1 and others in row are 0 due to elimination
        x[col] = b[r];
      }else{
        x[col]=0; // free var = 0
      }
    }
    return x;
  }

  async function cubesSolveAnimate(){
    const sol = cubesSolveExact();
    if(!sol){
      setStatus("No encontr√© soluci√≥n (raro). Usa Nuevo.");
      return;
    }
    const n = state.cubes.n;
    setStatus("Resolviendo‚Ä¶");
    for(let j=0;j<sol.length;j++){
      if(sol[j]===0) continue;
      while(state.paused) await new Promise(r=>setTimeout(r,140));
      const r = Math.floor(j/n), c=j%n;
      cubesToggle(state.cubes.cells, r,c,n);
      cubesRender();
      await new Promise(r=>setTimeout(r, 75));
    }
    markSolved("Perfecto. Ahora s√≠: caf√©.");
  }

  // =========================================================
  //                        MAZE
  // =========================================================
  function mazeGenerate(n){
    // grid with walls using DFS backtracker
    // cell: {visited, walls:[top,right,bottom,left]}
    const grid = Array.from({length:n}, () =>
      Array.from({length:n}, () => ({v:false, w:[1,1,1,1]}))
    );
    const stack = [];
    let cr=0, cc=0;
    grid[cr][cc].v=true;

    function neigh(r,c){
      const res=[];
      if(r>0 && !grid[r-1][c].v) res.push([r-1,c,0,2]); // top
      if(c<n-1 && !grid[r][c+1].v) res.push([r,c+1,1,3]); // right
      if(r<n-1 && !grid[r+1][c].v) res.push([r+1,c,2,0]); // bottom
      if(c>0 && !grid[r][c-1].v) res.push([r,c-1,3,1]); // left
      return res;
    }

    while(true){
      const ns = neigh(cr,cc);
      if(ns.length){
        const [nr,nc, wcur, wnext] = ns[Math.floor(Math.random()*ns.length)];
        // knock walls
        grid[cr][cc].w[wcur]=0;
        grid[nr][nc].w[wnext]=0;
        stack.push([cr,cc]);
        cr=nr; cc=nc;
        grid[cr][cc].v=true;
      }else if(stack.length){
        [cr,cc] = stack.pop();
      }else break;
    }

    // start/end
    const start=[0,0];
    const end=[n-1,n-1];
    return {grid,start,end};
  }

  function mazeDraw(){
    const m = state.maze;
    const {canvas, ctx} = m;
    const n = m.n;
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const cs = m.cellSize;

    // walls
    ctx.lineWidth = Math.max(1, Math.floor(cs*0.08));
    ctx.strokeStyle = "rgba(233,239,255,.85)";
    ctx.beginPath();
    for(let r=0;r<n;r++){
      for(let c=0;c<n;c++){
        const x=c*cs, y=r*cs;
        const w = m.grid[r][c].w;
        if(w[0]){ ctx.moveTo(x,y); ctx.lineTo(x+cs,y); }
        if(w[1]){ ctx.moveTo(x+cs,y); ctx.lineTo(x+cs,y+cs); }
        if(w[2]){ ctx.moveTo(x,y+cs); ctx.lineTo(x+cs,y+cs); }
        if(w[3]){ ctx.moveTo(x,y); ctx.lineTo(x,y+cs); }
      }
    }
    ctx.stroke();

    // path overlay
    if(m.path && m.path.length){
      ctx.strokeStyle = "rgba(106,228,255,.70)";
      ctx.lineWidth = Math.max(2, Math.floor(cs*0.14));
      ctx.lineCap="round";
      ctx.beginPath();
      for(let i=0;i<m.path.length;i++){
        const [r,c]=m.path[i];
        const cx=c*cs+cs/2, cy=r*cs+cs/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      }
      ctx.stroke();
    }

    // start/end
    const [sr,sc] = m.start;
    const [er,ec] = m.end;
    ctx.fillStyle="rgba(73,247,161,.75)";
    ctx.beginPath(); ctx.arc(sc*cs+cs/2, sr*cs+cs/2, cs*0.22, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,94,122,.75)";
    ctx.beginPath(); ctx.arc(ec*cs+cs/2, er*cs+cs/2, cs*0.22, 0, Math.PI*2); ctx.fill();

    // player
    const [pr,pc] = m.player;
    ctx.fillStyle="rgba(155,125,255,.85)";
    ctx.beginPath(); ctx.arc(pc*cs+cs/2, pr*cs+cs/2, cs*0.26, 0, Math.PI*2); ctx.fill();
  }

  function mazeNeighbors(r,c){
    const m = state.maze;
    const n = m.n;
    const cell = m.grid[r][c];
    const res=[];
    // top open?
    if(cell.w[0]===0 && r>0) res.push([r-1,c]);
    if(cell.w[1]===0 && c<n-1) res.push([r,c+1]);
    if(cell.w[2]===0 && r<n-1) res.push([r+1,c]);
    if(cell.w[3]===0 && c>0) res.push([r,c-1]);
    return res;
  }

  function mazeSolvePath(){
    const m = state.maze;
    const n=m.n;
    const start = m.player;
    const goal = m.end;

    // BFS is enough for maze
    const q=[start];
    const key = (r,c)=> r+","+c;
    const prev = new Map();
    prev.set(key(start[0],start[1]), null);

    while(q.length){
      const [r,c]=q.shift();
      if(r===goal[0] && c===goal[1]) break;
      for(const [nr,nc] of mazeNeighbors(r,c)){
        const k=key(nr,nc);
        if(prev.has(k)) continue;
        prev.set(k, [r,c]);
        q.push([nr,nc]);
      }
    }
    const endKey = key(goal[0],goal[1]);
    if(!prev.has(endKey)) return null;

    const path=[];
    let cur=goal;
    while(cur){
      path.push(cur);
      cur = prev.get(key(cur[0],cur[1]));
    }
    path.reverse();
    return path;
  }

  function mazeTryMove(dr,dc){
    if(state.paused || state.solved) return;
    const m=state.maze;
    const [r,c]=m.player;
    const nr=r+dr, nc=c+dc;
    if(nr<0||nc<0||nr>=m.n||nc>=m.n) return;

    // check walls from current cell
    const w=m.grid[r][c].w;
    if(dr===-1 && w[0]) return;
    if(dc=== 1 && w[1]) return;
    if(dr=== 1 && w[2]) return;
    if(dc===-1 && w[3]) return;

    m.player=[nr,nc];
    incMove();
    m.path = null; // clear any old path overlay when moving
    mazeDraw();

    if(nr===m.end[0] && nc===m.end[1]){
      markSolved(`Movs: ${state.moves}`);
    }else{
      setStatus("Encuentra la salida. S√≠, la vida tambi√©n. üòÖ");
    }
  }

  function mazeRender(){
    playArea.innerHTML="";
    const n = state.maze.n;
    const canvas = document.createElement("canvas");
    // internal resolution for crisp lines
    const size = 720;
    canvas.width = size;
    canvas.height = size;

    state.maze.canvas = canvas;
    state.maze.ctx = canvas.getContext("2d", {alpha:true});
    state.maze.cellSize = size / n;

    playArea.appendChild(canvas);

    // touch pad controls (mobile-friendly)
    const pad = document.createElement("div");
    pad.className="touchPad";
    pad.innerHTML = `
      <button class="ghost" data-dir="up">‚¨Ü</button>
      <button class="ghost mid"></button>
      <button class="ghost" data-dir="right">‚û°</button>
      <button class="ghost" data-dir="left">‚¨Ö</button>
      <button class="ghost mid"></button>
      <button class="ghost" data-dir="down">‚¨á</button>
    `;
    pad.addEventListener("click", (e)=>{
      const b=e.target.closest("button[data-dir]");
      if(!b) return;
      const d=b.getAttribute("data-dir");
      if(d==="up") mazeTryMove(-1,0);
      if(d==="down") mazeTryMove(1,0);
      if(d==="left") mazeTryMove(0,-1);
      if(d==="right") mazeTryMove(0,1);
    });
    playArea.appendChild(pad);

    // keyboard
    window.onkeydown = (e) => {
      if(state.mode!=="maze") return;
      const k=e.key;
      if(k==="ArrowUp") mazeTryMove(-1,0);
      if(k==="ArrowDown") mazeTryMove(1,0);
      if(k==="ArrowLeft") mazeTryMove(0,-1);
      if(k==="ArrowRight") mazeTryMove(0,1);
    };

    mazeDraw();
  }

  async function mazeSolveAnimate(){
    const m = state.maze;
    const path = mazeSolvePath();
    if(!path){ setStatus("No encontr√© ruta (raro). Usa Nuevo."); return; }
    m.path = path;
    mazeDraw();
    setStatus("Ruta mostrada. (Resolver = mostrar camino)");
  }

  // =========================================================
  //                    Mode switching & actions
  // =========================================================
  function updateHeaders(){
    const modeLabel = state.mode==="slide" ? "Deslizante" : state.mode==="cubes" ? "Cubos" : "Laberinto";
    const levelLabel = state.level==="low" ? "Bajo" : state.level==="mid" ? "Medio" : "Alto";
    ui.stageTitle.textContent = modeLabel;
    ui.stageSub.textContent = "Nivel " + levelLabel;
  }

  function snapshotCurrent(){
    if(state.mode==="slide"){
      state.snapshot = { board: state.slide.board.slice(), n: state.slide.n };
    }else if(state.mode==="cubes"){
      state.snapshot = { cells: state.cubes.cells.slice(), n: state.cubes.n };
    }else{
      state.snapshot = {
        n: state.maze.n,
        grid: state.maze.grid, // grid is object; ok to keep reference as snapshot for restart
        start: [...state.maze.start],
        end: [...state.maze.end],
        player: [...state.maze.start],
        path: null
      };
    }
  }

  function applySnapshot(){
    if(!state.snapshot) return;
    if(state.mode==="slide"){
      state.slide.n = state.snapshot.n;
      state.slide.board = state.snapshot.board.slice();
      slideRender();
    }else if(state.mode==="cubes"){
      state.cubes.n = state.snapshot.n;
      state.cubes.cells = state.snapshot.cells.slice();
      cubesRender();
    }else{
      state.maze.n = state.snapshot.n;
      state.maze.grid = state.snapshot.grid;
      state.maze.start = [...state.snapshot.start];
      state.maze.end = [...state.snapshot.end];
      state.maze.player = [...state.snapshot.player];
      state.maze.path = null;
      mazeRender();
    }
  }

  function newGame(){
    updateHeaders();
    resetCounters();
    resetTimer();
    startTimer();
    setStatus("¬°Juego nuevo! Dale.");

    if(state.mode==="slide"){
      const n = preset("slide", state.level);
      state.slide.n=n;
      state.slide.board = slideGenerate(n);
      slideRender();
    }
    if(state.mode==="cubes"){
      const n = preset("cubes", state.level);
      state.cubes.n=n;
      state.cubes.cells = cubesGenerate(n);
      cubesRender();
    }
    if(state.mode==="maze"){
      const n = preset("maze", state.level);
      state.maze.n=n;
      const g = mazeGenerate(n);
      state.maze.grid = g.grid;
      state.maze.start = g.start;
      state.maze.end = g.end;
      state.maze.player = [...g.start];
      state.maze.path = null;
      mazeRender();
    }
    snapshotCurrent();
  }

  function restartGame(){
    if(!state.snapshot){
      setStatus("Primero crea un juego con ‚ÄúNuevo‚Äù.");
      return;
    }
    resetCounters();
    resetTimer();
    startTimer();
    setStatus("Reiniciado. Esta vez s√≠, sin distracciones üëÄ");
    applySnapshot();
  }

  function clearGame(){
    if(state.mode==="slide"){
      // "Limpiar" = ponerlo en estado resuelto (√∫til si quieres volver a explicar)
      const n = state.slide.n || preset("slide", state.level);
      state.slide.n=n;
      state.slide.board = Array.from({length:n*n}, (_,i)=> i===n*n-1?0:i+1);
      slideRender();
      resetCounters();
      setStatus("Tablero limpio (resuelto).");
      setResult("‚Äî");
    }else if(state.mode==="cubes"){
      // clear = apagar todo
      state.cubes.cells = Array(state.cubes.n*state.cubes.n).fill(0);
      cubesRender();
      resetCounters();
      setStatus("Todo apagado. Paz interior simulada.");
    }else{
      // maze clear = quitar ruta
      state.maze.path = null;
      mazeDraw();
      setStatus("Ruta limpia.");
      setResult("‚Äî");
    }
  }

  async function solveGame(){
    if(state.solved){ setStatus("Ya est√° resuelto. No presumas. üòÑ"); return; }
    if(state.mode==="slide"){
      await slideSolveAnimate();
    }else if(state.mode==="cubes"){
      await cubesSolveAnimate();
    }else{
      await mazeSolveAnimate();
    }
  }

  function renderEmpty(){
    playArea.innerHTML = `<div style="max-width:520px;text-align:center;color:rgba(233,239,255,.88);">
      <div style="font-size:18px;font-weight:800;margin-bottom:8px;">üëã Elige un modo y dale a <b>Nuevo</b></div>
      <div style="color:rgba(159,176,255,.92);font-size:13px;line-height:1.35;">
        Esto es un archivo √∫nico. S√∫belo a una web (GitHub Pages / Netlify / Vercel) y comparte el link en WhatsApp o Facebook.
      </div>
    </div>`;
  }

  // ---------- Wire UI ----------
  ui.mode.addEventListener("change", () => {
    state.mode = ui.mode.value;
    updateHeaders();
    renderEmpty();
    setStatus("Cambia de modo y presiona ‚ÄúNuevo‚Äù.");
    // update hint
    ui.hint.innerHTML =
      state.mode==="slide" ? "<b>Deslizante:</b> toca una ficha junto al hueco. <br/>Nivel: 3x3 / 4x4 / 5x5. <br/><i>Resolver:</i> A* para 3x3; modo r√°pido para 4x4+."
    : state.mode==="cubes" ? "<b>Cubos:</b> toca para alternar (tipo Lights Out). <br/>Nivel: 4x4 / 5x5 / 6x6. <br/><i>Resolver:</i> soluci√≥n exacta por √°lgebra (GF(2))."
    : "<b>Laberinto:</b> flechas del teclado o botones en pantalla. <br/>Nivel: 15 / 23 / 31. <br/><i>Resolver:</i> muestra el camino.";
  });

  ui.level.addEventListener("change", () => {
    state.level = ui.level.value;
    updateHeaders();
    setStatus("Nivel cambiado. Presiona ‚ÄúNuevo‚Äù para aplicarlo.");
  });

  ui.btnNew.addEventListener("click", newGame);
  ui.btnRestart.addEventListener("click", restartGame);
  ui.btnClear.addEventListener("click", clearGame);
  ui.btnSolve.addEventListener("click", solveGame);
  ui.btnPause.addEventListener("click", () => {
    if(!state.timerId){ setStatus("Primero crea un juego con ‚ÄúNuevo‚Äù."); return; }
    pauseToggle();
    setStatus(state.paused ? "Pausado." : "Reanudado.");
  });

  // init
  updateHeaders();
  renderEmpty();
})();
</script>
</body>
</html>
